## CSRF跨站请求攻击

现在有如下情景：
现在有网站A的地址为a.test.com,我在这个网站有些重要的信息，比如现金等，每次在A网站登陆后服务器都会返回给我session id用来做后面的请求的身份校验，并且这个session id是用cookie存储在客户端的，又并且这个cookie的域名是.test.com（这样我访问其他以test.com为主域名的网站就不用重新登录了）。
现在我访问一个网站B，这个B网站的域名不确定。在这个B网站中，发送了一个请求到A网站，因为请求是到A网站的，所以请求就会携带我刚刚在A网站登陆后保存的cookie信息，其中就有用来校验身份的session id，那么A网站收到这个包含合法session id的请求后就会认为这是我本人发送出来的，所以A网站就会响应这个请求。
假如B网站是个非法网站，那么通过以上操作B网站就能获取到我的一些私人信息-----以上这个过程就是CSRF跨站请求攻击。

简单来说：浏览器发出了非用户自愿发出的请求，这个请求就是一个跨站请求，整个发出跨站请求的行为就是跨站请求攻击。

**简单的身份认证只能保证请求发自某个用户的浏览器，但不能保证请求本身是用户自愿发出的。**

所以，总结一下，CSRF攻击大致有以下特点：
* 利用session id使用cookie存储，而请求会自动携带同一域名下的cookie特性
* 跨站
* CSRF利用的是网站对用户网页浏览器的信任（身份验证通过后就认为是用户发来的请求）。



### 如何解决

1.__针对跨站，同源检测__：HTTP的头部有一个**Referer**字段，用来表明请求源自哪个地址，通过后端校验该字段，就能知道请求是否发自一个合法的网站，由此避免了CSRF的跨站的特性（我理解这种方式是十分不靠谱的，既然人家有能力攻击你，就肯定知道本机host可以配置，同样的还有个Origin头部字段）。

2.__Token验证（针对使用cookie进行身份校验的验证方式）__：由于CSRF利用了浏览器自动传递cookie的特性，所以另外一个防御思路就是校验信息不通过cookie传递，在其他参数中增加随机加密串进行校验（在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie中）：

* 随机字符串Token：为每一个提交增加一个随机串参数，该参数通过服务端页面下发，每次请求时补充到提交参数中，服务器端拥有一个拦截器来验证这个token。如果请求中没有token或者token不正确，则可以认为是CSRF攻击而拒绝该请求。有以下几种使用token防止跨站脚本攻击的方法：
  * 令牌同步模式：在用户请求的页面中的表单中嵌入一个token，在服务端校验这个token。token可以是任意的内容，但是一定要保证无法被攻击者猜测或者查询到。攻击者在请求中无法使用正确的token，也就无法发起攻击（感觉和上面的随机字符串token有点类似）
  * cookie-to-header Token：对于使用js作为主要交互技术的网站，将CSRF的token写入到cookie中，然后使用js读取token的值，在发送请求的时候将其作为请求的header，服务器端接收到请求后校验对应的头部字段判断是否是合法的请求。

3.**验证码**：强制用户必须与应用进行交互，才能完成最终请求。通常情况下，验证码能够很好的遏制CSRF攻击。但是出于用户体验的考虑，网站不能给所有的操作都加上验证码，因此验证码只能作为一种辅助手段。

4.尽量使用POST，限制GET请求：GET接口能够直接将请求地址暴露给攻击者，所以要防止CSRF最好不要用GET请求。POST请求也可以被CSRF，但需要第三方在页面构造一个form表单，这样就增加了暴露的可能性。（我理解这条也是没啥用的，把黑客想的太简单了）

5.**在HTTP头部添加自定义属性**。

6.使用cookie的Samesite属性，它表示这个cookie是个**同站**cookie，同站cookie只能作为第一方cookie，不能作为第三方cookie。Samesite=Strict表示这个cookie在任何情况下都不可能作为第三方cookie。Samesite=Lax表示假如这个请求改变了当前页面或者打开了新页面且同时是个get请求，则这个cookie可以作为第三方cookie。

```
Set-cookie: foo=1; Samesite=Strict
Set-cookie: bar=2; Samesite=Lax
Set-cookie: baz=3;
```

例如在b.com下设置了如上的cookie。我们在a.com下发起对b.com的请求，foo和bar这两个cookie都不会被包含在cookie请求头中，但是baz会。

当用户从a.com点击链接进入b.com时，foo这个cookie不会被包含在cookie请求头中，但是bar和baz会。

如果请求时从a.com发起的对b.com的异步请求，或者页面转跳时通过表单的post提交触发的，则bar也不会发送。

但是Samesite目前还不成熟，支持的浏览器不多，应用场景有待观望。

参考：
​	http://www.cnblogs.com/ziyunfei/p/5637945.html
​	https://juejin.im/post/58c669b6a22b9d0058b3c630
​	https://segmentfault.com/a/1190000008505616