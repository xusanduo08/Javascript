### 环视：

> 环视的概念：环视强调的是它所在的位置，前面或者后面，必须满足环视表达式中的匹配情况，才能匹配成功，环视并不消耗正则的匹配字符，可以认为是虚拟加入到它所在__位置__的附加判断条件。
>
> 因为正则表达式是按照单个字符进行匹配的，一般情况下是从左到右，逐个匹配源字符串中的东西，当源字符串中的某个字符被匹配到以后，该字符串就不会进入下一个正则匹配的过程中，也就是说，这个字符串被消耗了。
>
> 或者，对于不消耗匹配字符还可以这么理解,`RegExp`对象都有一个`lastIndex`属性，这个属性表示下一次匹配的开始位置，而对于环视来讲，当进行到环视的匹配时，正则表达式的`lastIndex`不会改变。

我的理解，环视限制了它所在位置能有什么和不能有什么，注意，这里强调的是__位置__。

环视主要有四种，分别如下：

* 顺序肯定环视`(?=exp)`
* 顺序否定环视`(?!exp)`
* 逆序肯定环视`(?<=exp)`
* 逆序否定环视`(?<!exp)`

### 环视的使用

看一下环视如何使用，下面的正则表达式：

> `var regex=/^(?![a-z]+$)(?![A-Z]+$)(?!\d+$)[a-zA-Z\d]{8,12}/`

来解析一下上面的正则表达式：

`(?![a-z]+$)`：`?!`表示顺序否定环视，表示该位置不能有什么。现在这个表达式放在开头，说明开头位置不能全是小写字母；

`(?![A-Z]+$)`：表示不能全是大写字母；

`(?!\d+$)`：表示不能全是数字；

`[a-zA-Z\d]{8,12}` ：匹配到这里，由于环视不消耗匹配字符，所以此时的`lastIndex`仍然为0，也就是说`[a-zA-Z\d]{8,12}`匹配时仍然从源字符串的开头开始匹配，所以总的来说，上面的正则匹配的是--至少包含大写字母、小写字母、数字中的两种，并且长度为8~12位。

### 正则匹配的过程

```
regex.test('1234567891234');//false
regex.test('1234567a');//true
```

以上面两个表达式为例，说一下正则的匹配过程：

​	先说正则表达式的两个特点：1、默认情况下匹配都是贪婪的；2、引擎会返回最先匹配到的结果

​	第一个例子：首先`(?![a-z]+$)`会去匹配，是否全是小写字母，`lastIndex`此时为0，该位置字符串为`1`,所以匹配结果是`true`；接着`(?![A-Z]+$)`再去匹配，是否全是大写字母，`1`不是大写字母，返回结果--不是，接下来`(?!\d+$)`进行匹配，从索引0位置开始，`1`是数字，不符合不全是数字的条件，所以将`lastIndex`后移一位，接下来要匹配的是`12`，仍然不满足不全是数字的条件，所以，继续后移`lastIndex`，直到最后一位，匹配的字符串`1234567891234`依然不满足不全是数字的条件，这时已经尝遍了所有可能的情况，依然不满足条件，所以整个匹配结果返回`false`。

​	第二个例子：对于`(?![a-z]+$)`和`(?![A-Z]+$)`的匹配情况和第一个例子一样，直接来看`(?!\d+$)`的匹配。从0位置到6位置匹配结果一直是`false`，当`lastIndex`移动到6位置时，由于出现了一个小写字母`a`从而满足了不全是数字的条件，所以匹配通过。接下来，前面三个环视匹配的结果会作为一个范围送给`[a-zA-Z\d]{8-12}`去匹配，这时候要求只能是数字、小写字母、大写字母，长度必须在8~12之间，所以最终的匹配结果是`true`。

http://xz.jb51.net:81/201101/books/jtregex3_jb51.7z 精通正则表达式

`?!`：预判，从当前位置到尾部预览字符串

     密码强度: 
    8位字母数字的组合，至少包含一位大写字母和一位数字
        预判: 从头到尾预览字符串
        1. 不全由字母组成: (?![a-zA-Z]+$)
           结论: 至少包含一位数字，还可能有特殊符号
        2. 不全由小写字母和数字组成: (?![0-9a-z]+$)
           结论: 至少包含一位大写字母，还可能包含特殊符号
        3. 只能由字母和数字组成: [0-9A-Za-z]{8}
    	排除特殊符号的可能
    (?![a-zA-Z]+$)(?![0-9a-z]+$)[0-9A-Za-z]{8}