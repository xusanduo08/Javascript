### ES6的块级作用域

`let`命令相当于为`Javascript`创建了块级作用域。

```javascript
function f1(){
  	let n = 5;
  	if(true){
      	let n = 10;
  	}
  	console.log(n);//5
}
```

上面函数中有两个代码块，都声明了变量`n`，最后运行输出5。这表示外层代码块不受内层代码块的影响。如果都使用`var`定义变量`n`，最后输出的值就是10。

ES6允许作用域的嵌套，同时，外层作用域无法读取内层作用域的变量。

```javascript
{{{{
  {let insane = "Hello world"}
  console.log(insance);//报错 Uncaught ReferenceError: insance is not defined
}}}}
```

也就是说，不同块级作用域之间是相互隔离的。比如，内层作用域可以使用`let`定义外层作用域的同名变量。

```javascript
  {{{
    {let insane = "Hello world"}
    let insane = "Hello world"
  }}}
```

### 块级作用域与函数声明

ES5中规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明。

```javascript
if(true){
  	function f(){}
}

try{
  	function f(){}
} catch(e){
  	//..
}
```

上面两种函数的声明，根据ES5的规定都是非法的。但是浏览器没有遵守这个规定，上面的代码在浏览器中运行不会报错。

ES6中规定，块级作用域中，函数声明语句的行为类似`let`，在块级作用域之外不可引用。

```javascript
function f(){
  	console.log("I'm outside");
}
(function(){
  	if(false){
      	function f(){
          	console.log("I'm a inside!");
      	}
  	}
  	f();
})()
```

上面代码在ES5中运行得到的结果是“I'm inside"，因为在`if`内声明的函数`f`会被提升到当前作用域的头部，实际运行的代码如下。

```javascript
function f(){
  	console.log("I'm outside");
}
(function () {
  function f() { console.log('I am inside!'); }
  if (false) {
  }
  f();
}());
```

如果把上上面的代码放到ES6的浏览器中运行，是会报错的。

ES6中规定，允许在块级作用域内声明函数，函数声明类似于`var`，即会提升到全局作用域或函数作用域的头部，同时，函数声明还会提升到所在块级作用域的头部。

所以，根据上面三条规则，在浏览器的ES6环境中，块级作用域内声明的函数，行为类似于`var`声明的变量。

```javascript
function f(){
  	console.log("I'm outside");
}
(function(){
  	if(false){
      	function f(){
          	console.log("I'm a inside!");
      	}
  	}
  	f();
})()
//报错 Uncaught TypeError: f is not a function
```

上面的代码在ES6环境中，实际运行的是以下代码。

```javascript
function f(){
  	console.log("I'm outside");
}
(function (){
  	var f = undefined;
  	if(false){
      	function f(){
          	console.log("I'm a inside!");
      	}
  	}
  	f();
})()
//所以会报错 Uncaught TypeError: f is not a function
```

