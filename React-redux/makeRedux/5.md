针对上一节提到的问题，常规思路是用`shouldComponentUpdate()`优化，在方法中比较前后状态的改变，然后再决定是否要更新。但是这地方有些不一样，store是存储在上下文中的，组件自身没有存储上下文，`shouleComponentUpdate()`方法中无法获取变化前的数据。每次数据更新后，组件进行re-render时其所处就已经是最新的上下文了。那可不可以把状态值存储到state中，下次更新时拿最新的上下文中的store计算出来的state和组件中存储的状态值比较，然后判断是否更新？似乎可行，试一下：

```jsx
class Content extends Component{
    constructor(){
        super();
        this.state = {
            content:{}
        }
    }
    componentDidMount(){
      this.context.store.subscribe(() => { //  从上下文获取store
        this.setState({}); // 订阅store，数据有变化时，发起re-render
      })
      this.setState({content: this.context.store.getState().content})
    }
    componentDidUpdate(){
      console.log('Content didUpdate');
      this.setState({content: this.context.store.getState().content})
    }
    shouldComponentUpdate(nextProps, nextState){
      const {content} = nextState;
      const nextContent = this.context.store.getState().content;
      if(content.text !== nextContent.text || content.color !== nextContent.color){
        return true;
      }
      return false;
    }
    render(){
        return (
        	<div id='content'>
              {this.context.store.getState().content.text}
          	</div>
        )
    }
}
```

以上代码试了下，可以达到效果，`Title`更新时不会影响到`Content`。但这样看起来是不是有点烦？为了达到效果，重写了三个生命周期方法，而且订阅store还需要手动去订阅。可不可以抽取出一种公共方法，组件调用这个公共方法后就自动订阅到store上，而且这个方法内部也会优化组件的re-render。

先完成自动订阅功能，因为是连接了组件和store，所以把这个方法叫做`connect`。

```jsx
import React from 'react';
function connect(store, component){
    let state = store.getState();
    return class Connect extends React.Component{
        constructor(){
            super();
        }
        
        render(){
            return React.createElement(component)
        }
    }
}
```



