```javascript
// createStore
function createStore(state, reducer){
    const listeners = [];
    const subscribe = (listener) => listeners.push(listener);
    const getState = ()=> state;
    const dispatch = (action) => {
        state = reducer(state, action);
        listeners.forEach(listener => listener());
    };
    return {getState, dispatch, subscribe}
}

//index.js

```

上面是`createStore()`方法。在使用的时候，我们是将`store`作为最外层的组件`App`的props传入进去，然后由`App`将数据再以props的形式按需传给其他组件，当组件想要从store中获取数据时必须由父组件传给它。这样做有点麻烦，而且在数据一层层的传递过程中很容易产生问题，产生问题后又很难定位。此外，我们在使用时是将`ReactDOM.render()`方法订阅到了store上，有数据变化时整个组件树都会re-render，为了避免性能问题，还要在每个组件中重写`shouldComponentUpdate()`方法，这样做也是比较麻烦的，一个应用中组件有很多，每个组件都写`shouldComponentUpdate()`方法真的很烦，而且，有的组件可能根本就不需要从store中获取数据，再因为store发生变化专门写个`shouldComponentUpdate`显得有点啰嗦了。

有没有一种方法，可以让组件各自按需去订阅store？这样store发生变化时就只会更新那些订阅store的组件而不是整棵组件树。

我们以这个为目标，试着实现以下。

让组件按自身需要去订阅store，可以这么做，把store传入到`App`中，`App`再将store传入`Title`和`Content`中。

```jsx
//index.js
ReactDOM.render(<App store={store} />, document.getElementById('root'));

//App.js
class App extends Component {
    shouldComponentUpdate(nextProps){
        if(this.props.book !== nextProps.book){
            return true;
        }
        return false;
    }
    
    render(){
        return (
            <div>
        		<Title store={this.props.store} />
        		<Content store={this.props.store} />
        	</div>
        )
    }
}

//Title.js
class Title extends Component{
    componentDidMount(){
        this.props.store.subscribe(() => {
            this.setState({}); // 订阅store，数据有变化时，发起re-render
        })
    }
    shouldComponentUpdate(nextProps){
        // 这地方不好处理了，前后props中的store都是同一个值
        const state = this.props.store.getState();
        const nextState = this.props.store.getState();
        if(this.props.store.title !== nextProps.store.title){
            return true;
        }
        return false;
    }
    render(){
        return (
        	<div id='title' style={{color: this.props.title.color}}>
                {this.props.store.title.text}
            </div>
        )
    }
}
```

