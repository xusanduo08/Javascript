<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <script src="lodash.js"></script>
</head>
<body>
    
</body>
    <script>
        function Scope(){
            this.$$watchers = [];
            this.$$asyncQueue = [];
            this.$$phase = null; //存储正在做的信息
            this.$$postDigestQueue = [];
        }
        //每个scope实例都需要有$watch, 所以放在原型上
        Scope.prototype.$watch = function(watchFn, listenerFn, valueEq){
            var self = this;
            var watcher = {
                watchFn: watchFn, //监控函数，返回值应该是最新的数据
                listenerFn: listenerFn || function(){}, //监听函数，用于在数据变化时的时候接受提示
                valueEq: !!valueEq      //是否开启基于值的脏检查
            }
            self.$$watchers.push(watcher);
            return function(){
                var index = self.$$watchers.indexOf(watcher);
                if(index >= 0){
                    self.$$watchers.splice(index, 1);
                }
            }
        }
        
        //基于值的脏检查意味着如果新旧值是对象或者数组，那么我们必须遍历其中包含的所有内容。如果他们之间有任何差异，监听器就脏了。
        //如果该值包含嵌套的对象或者数组，它也会递归的按值比较。
        Scope.prototype.$$areEqual = function(newValue, oldValue, valueEq){
            if(valueEq){
                return _.isEqual(newValue, oldValue);
            } else {
                return newValue === oldValue ||
                (typeof newValue === "number" && typeof oldValue === "number" && isNaN(newValue) && isNaN(oldValue));  //处理NaN
            }
        }


        //以上已经可以实现Angular的几个特性：添加监听器、在digest里运行它们
        //监听函数自身也可以修改作用域上的属性。如果这个发生了，另外有个监听器在监控被修改的属性，有可能在同一个digest里面检测不到这个变动。
        
        //运行一次所有的监听器
        Scope.prototype.$$digestOnce = function(){
            var self = this;
            var dirty;
            
            _.forEach(this.$$watchers, function(watch){ 
                try{
                    var newValue = watch.watchFn(self);
                    var oldValue = watch.last;
                    if(!self.$$areEqual(newValue, oldValue, watch.valueEq)){
                        watch.listenerFn(newValue, oldValue, self);
                        dirty = true;
                    }
                    watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue);
                }catch(e){
                    console.log(e);
                }
                
            })
            return dirty;
        }

        //$digest作为一个“外层循环”来运行，当有变更发生的时候，调用$$digestOnce
        //确保有变化发生时能至少运行一次脏检查，如果有变化发生，则会至少运行2次
        Scope.prototype.$digest = function(){
            var dirty;
            var ttl = 10;//可迭代的最大次数
            this.$beginPhase("$digest");
            do{
                while(this.$$asyncQueue.length){
                    try{
                        var asyncTask = this.$$asyncQueue.shift();
                        this.$eval(asyncTask.expression);    
                    } catch(e){
                        console.log(e);
                    }
                    
                }
                dirty = this.$$digestOnce();
                if(dirty && !(ttl--)){
                    this.$clearPhase();
                    throw "10 digest iterations reached";
                }
            } while(dirty);
            this.$clearPhase();

            while(this.$$postDigestQueue.length){
                try{
                    this.$$postDigestQueue.shift()();
                } catch(e){
                    console.log(e);
                }
            }
        };

        //$eval 在作用域的上下文执行代码
        Scope.prototype.$eval = function(expr, locals){
            return expr(this, locals);
        }
        //$apply 执行一些与angular无关的代码，这些代码可以改变作用域上的东西，$apply可以保证作用域上的监听器可以检测到这些变更。
        Scope.prototype.$apply = function(expr){
            try{
                this.$beginPhase("$apply");
                return this.$eval(expr);
            } finally{
                this.$clearPhase();
                this.$digest();
            }
        }

        Scope.prototype.$evalAsync = function(expr){
            var self = this;
            //检测当前作用域上现有的阶段变量，如果没有（也没有已列入计划的异步任务），就把这个digest列入计划。
            //有了这个实现后，不管何时，何地，调用$evalAsync，都可以确定有一个$digest会在不远的将来发生。
            if(!self.$$phase && !self.$$asyncQueue.length){
                setTimeout(function(){
                    if(self.$$asyncQueue.length){
                        self.$digest();
                    }
                }, 0);
            }
            this.$$asyncQueue.push({scope: this, expression: expr})
        }

        Scope.prototype.$beginPhase = function(phase){
            if(this.$$phase){
                throw this.$$phase + "already in progress"
            }
            this.$$phase = phase;
        }
        Scope.prototype.$clearPhase = function(){
            this.$$phase = null;
        }

        //把一个函数列入计划，这个函数将在下一次digest完成之后运行。
        Scope.prototype.$$postDigest = function(fn){
            this.$$postDigestQueue.push(fn);
        }

        var scope = new Scope();
        scope.firstName = "Joe"
        scope.counter1 = 0;
        scope.counter2 = 1;
        scope.counterByRef = 0;
        scope.counterByValue = 0;
        scope.value = [1, 2, {three: [4, 5]}];
        scope.asyncEvaled = false;
        scope.$watch(function(scope){
            return scope.avalue;
        }, function(newValue, oldValue, scope){
            scope.counter++;
            scope.$evalAsync(function(scope){
                scope.asyncEvaled = true;                
            })
            console.log("inside listener" + scope.asyncEvaled);
        })
        scope.avalue = "text";
        scope.$digest();


    </script>
</html>
