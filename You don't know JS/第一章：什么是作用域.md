### 你不知道的JS：作用域和闭包

### 第一章：什么是作用域？

目前几乎所有编程语言都具有将值存储到变量中，在随后的程序中取出或者修改这些值的能力。这种存储值到变量中并且将值取出来的能力给与了程序一种“状态”。

如果没有上面所说的能力，程序依然可以做一些工作，但它们的能力将会受到极大的限制。

上面所说的能力带来了一个问题，那就是：这些变量存储在什么地方？程序是如何发现这些变量以及如何确定何时需要它们的？

回答这些问题之前需要定义一些规则，通过这些规则，我们能在指定区域存储变量，也能在使用时找到这些变量。我们称这一系列规则为：**作用域**。

~~回答这些问题需要一系列定义好的规则以便用来在某区域存储变量以及能在使用时找到这些变量。我们将这一系列规则称为：__作用域__。~~

那么，这些规则在什么地方、是被如何定义的呢？

#### 编译器理论

根据对各种编程语言的了解程度，有的人觉得以下内容是不证自明的，也有人觉得这非常有趣：尽管Javascript一直被认为是一个“动态的”、“解释型”语言，但事实是Javascript是一个编译型语言。它并不会像其他传统的编译语言一样事先编译好，编译结果也不能在各种分布式系统中完美运行。

但尽管如此，Javascript的引擎还是以一种非常精巧的、难以察觉的方式进行着和传统语言编译器相同的操作。

在传统的编译型语言中，一段代码在被执行前需要经过三个步骤，这三个步骤可以被合称为“编译”：

1. **分词/词法分析**：将一段字符串拆分成有意义的（对语言来说）片段，这些有意义的片段称为token，这个操作称为**分词**。例如下面一段代码`var a = 2`，这段代码会被拆分成下面几个token：`var`、`a`、`=`、`2`，还有`;`。空格会根据其是否有意义来决定其是否会被保留为一个token。

   **注意**：分词和词法分析之间的区别是微妙的，而且具有学术性质，其中心点在于是否通过有无状态来标识token。简单的说，如果分词器通过有状态的规则去判断`a`是一个独立的token还是另一个token的一部分，那这一过程就是**词法分析**。

2. **解析**：输入一组toke流（数组），并通过元素嵌套的方式将其转换成一棵树，这棵树代表了程序的语法结构。这这棵树被叫做“AST”（抽象语法树，Abstract Syntax Tree）。

   代码`var a = 2`的语法树以一个被称为`VariableDeclaration`（变量声明）的头级节点开始，该节点带有一个值为`a`的子节点，称为`Identifier`（标识符）。另一个子节点叫做`AssignmentExpression`（赋值语句），该节点自身带有一个子节点，叫做`NumericLiteral`（数字字面量），其值为`2`。

3. **代码生成**：将抽象语法树转成可执行代码的过程。这一过程中，不同的语言，不同的目标平台，操作会有较大不同。

   所以，与其迷失在细节中，不如简单的说有一种方法能将上面描述`var a = 2`的抽象语法树转换成一串机器可执行的指令并真正的创建一个变量`a`（包括保存在内存中），然后将值存储到`a`中。

   **注意**：关于引擎如何调用系统资源的细节我们不做讨论，我们假设引擎有能力去根据需要创建和存储变量。

上面三步只是对编译过程的简单描述。Javascript的引擎和其他语言的一样，编译过程都比上面描述的复杂。例如在解析和代码生成过程中，都会有专门的步骤去优化执行效率，比如合并冗余代码等等。

另外，Javascript的引擎并没有很多的时间去做代码优化，因为它没有专门的构建步骤，这一点和其他编译器不一样。

对于Javascript来说，留给编译步骤的时间只有几微秒，甚至更少，紧接着就是代码执行。为了更快的性能，JS引擎用了各种技巧（比如 JIT，它可以懒编译甚至热编译），当然这不在我们要讨论的“作用域”范围内。

为了简单起见，我们说，任何Javascript代码片段~~在执行前（通常是_刚好_在执行前）都要被编译~~都要先编译再执行（执行通常紧挨着编译）。综上，对于`var a = 2`来说，JS编译器会接收这段代码，然后先编译它，再接着就是执行，这两步往往是紧挨着。

#### 理解作用域

我们把作用域的工作想象成一段对话，以此来理解作用域。但是，谁在进行这场对话呢？

##### 角色

先来介绍下在`var a = 2`这段代码中出现的角色，然后再去理解它们的对话：

1. 引擎：负责编译过程的开始和结束，以及代码的执行
2. 编译器：引擎的朋友之一。负责解析和代码生成过程中的所有工作（见上一节）
3. 作用域：引擎的另一个朋友。负责收集所有声明过的标识符（变量），同时维护一个可供查找的由所有声明过的标识符（变量）组成的列表，并且设定了一系列如何在当前代码中获取这些变量的严格的规则

为了能全面的理解Javascript的工作，你需要开始像引擎和它的朋友们那样的思考，问它们问的问题并回答这些问题。

##### 反复

当你看到`var a = 2`这段代码时，你会认为这仅是一段声明而已。但我们的新朋友-----引擎并不这么认为。事实上，引擎会认为这是两段不同的声明，一段由编译器在编译阶段处理，一段由引擎在代码执行时处理。

下面，我们来分解下引擎和它的朋友处理`var a = 2`这段代码的过程。

编译器要做的第一件事就是词法分析，将这段代码分成若干个token，然后将这些token解析成抽象语法树。接下来编译器进入代码生成阶段，~~这一阶段和正常所认为的不一样~~这一阶段的处理将会和我们所想的有些不一样。

大部分人觉得编译器~~生成代码的过程~~生成的代码可以被总结成下面一句话：给变量分配内存，标记为`a`，然后将值`2`存储到这个变量中。不幸的是，这种描述并不准确。

编译器实际会进行如下过程：

1. 遇到`var a`代码后，编译器会询问作用域，在指定的作用域中，变量`a`是否已经存在，如果已经存在，编译器会忽略当前这个声明并继续往下工作；否则，编译器会让作用域在指定作用域中声明一个新的叫做`a`的变量。
2. 接着编译器生成供引擎执行的代码，让引擎处理`a = 2`这段赋值操作。引擎运行代码时，~~会先询问作用域~~代码首先会让引擎询问当前作用域，在当前作用域中是否已经存在一个叫做`a`的变量。如果存在，引擎就使用这个已经存在的变量，否则，引擎会去其他地方询问（具体请查看后面的章节）

如果引擎最终找到了这个变量，就会把`2`赋值给它；否则，引擎就会抛出一个错误。

总结一下：变量的赋值需要两个的操作：首先，编译器声明变量（如果这个变量在当前作用域没有声明过的话），然后在执行代码时，引擎会去作用域中寻找已经声明的变量，如果找到了就将值赋值给它。

##### 编译器术语

我们需要一些编译器术语来方便后面我们的理解。

当引擎在执行编译器生成的代码时，引擎需要去知道变量`a`是否已经被声明，所以就去查找这个变量，而这个查找过程其实就是去询问作用域。引擎采取的查找类型影响着查找结果。

在我们上面的例子中（`var a = 2`），引擎会执行一次“LHS”去寻找变量`a`（左查询）。另一个查找类型叫做“RHS”（右查询）。

我打赌你能猜到“L”和“R”代表的啥，它们分别代表“左边”和“右边”。

那么，这个“左边”、“右边”是相对于谁的“左边”、“右边”呢？**相对于赋值操作**。

换句话说，赋值操作左边存在变量时，会执行一次左查询；赋值操作右边存在变量时，会执行一次右查询。

但事实上，右查询有些难以察觉，因为它仅仅去查询一个变量所存储的值。而左查询则尝试去寻找变量的容器本身，以便进行赋值操作。这样来说的话，右查询并不是严格意义上的“赋值操作的右边”，更确切的说，“非左查询”更合适。

也可以简单的理解：右查询表示去获取源，也就是说，RHS是用来获取某些值的。

继续深入。

看下面代码：

```javascript
console.log(a)
```

上面代码中，指向`a`的引用就是一个RHS引用，因为这地方并没有任何值赋给`a`。在这里，我们是在查询并获取`a`的值，然后将获取到的值传递给`console.log(..)`操作。

相反的：

```javascript
a = 2;
```

上面代码中，指向`a`的引用就是一个LHS引用，因为我们并不关心当前`a`的值是啥，我们只是想找到这个变量作为赋值目标，然后完成`= 2`的赋值操作。

**注意**：LHS和RHS表示“赋值操作的左右两边”并不能从字面意义上理解成“`=`操作符的左右两边”。赋值有很多种完成方式，所以最好这样理解：赋值的目标需要LHS，赋值的数据来源需要RHS。

考虑下面这段代码，里面包含了LHS和RHS引用：

```javascript
function foo(a){
	console.log(a); // 2
}
foo(2);
```

上面代码的最后一行触发了函数运行，在触发时需要RHS引用来获取`foo`的指向----“寻找`foo`的值，找到后交给我”。而且，`(...)`表示要执行`foo`，所以它的值应当是个函数。

这地方有个微妙但很重要的赋值，**你发现了么**？

你可能忽略了这段代码里一行实现：`a = 2`。当数值`2`作为参数传入到方法`foo(...)`中时，`2`就会被赋值给形参`a`。为了完成赋值操作，需要执行一次LHS。

代码中也有RHS来查询`a`的数值，查询到的结果传递给了`console.log(...)`。`console.log(...)`的执行需要一个引用。先是一个右查询去查询`console`对象，然后再进行属性解析来判断一下`console`对象是否含有叫`log`的方法。

最后，从概念上来说，在将`2`传入（通过对变量`a`的右查询）到`log(...)`时轮流进行着LHS/RHS。在`log(...)`的原生内部实现中，我们假定它含有形参，在将`2`赋值给第一个参数（或许叫`arg1`）时，进行了一次LHS引用查询。

（译者：先RHS从`a`中取出值，然后将值赋值给`log(arg1)`中的参数`arg1`）

**注意**：你可能认为从概念上来讲`function foo(a){...}`是一次普通的变量声明和赋值操作，就像`var foo`以及`foo = function(a){...}`一样，。这样做会让你认为函数声明需要一次左查询。

但比较难以察觉的是，在代码生成阶段编译器既进行声明也进行了值的定义，这样引擎在执行代码时，不需要再将函数值赋值给`foo`。因此，把函数声明认为成我们上面讨论的左查询然后赋值的操作并不合适。

##### 引擎/作用域对话

```javascript
function foo(a) {
    console.log(a); // 2
}
foo(2);
```

我们把上面的操作想象成一段对话，这段对话大概下面整个样子：

> 引擎：嗨，作用域，我需要一个`foo`的RHS引用，你听过这个变量么？
> 作用域：是的，我有这个变量。编译器刚刚声明了这个变量。这是你要的函数，给你。
> 引擎：太棒了，谢谢你！好了，我开始执行`foo`了。
> 引擎：嗨，作用域，我需要要一个`a`的LHS引用，你听过这个变量么？
> 作用域：是的，我有这个变量。作为`foo`的参数，编译器刚声明了它，给你。
> 引擎：太棒了，作用域。再次感谢。现在，将`2`赋值给`a`。
> 引擎：嗨，作用域，很抱歉再次打扰你。我需要一个对`console`的RHS，你见过这个变量么？
> 作用域：没关系，这是我的工作。我有这个变量`console`，它是内置的，给你。
> 引擎：完美。查找`log(...)`。好，完美，这是个函数。
> 引擎：作用域，你能帮我找下`a`的RHS的引用么，我记得这个变量，但我想确认下。
> 作用域：引擎，你是对的。这个变量确实存在，而且没有变过。给你。
> 引擎：棒！。将`a`的值`2`传递到`log(..)`中。
##### 测验
检测下目前你理解的知识：
```javascript
function foo(a){ // 一个LHS完成a的赋值
  var b = a; // 一个LHS给b，一个RHS给a
  return a + b;// a和b各需要一个RHS
}
var c = foo(2); // 一个LHS完成c的赋值，一个RHS查询foo的值
```
1. 找出所有LHS（总共有3处）（译者：`c`的赋值，`a`的赋值，`b`的赋值）
2. 找出所有的RHS（总共有4处）（译者：查询`foo`的值，查询`a`的值两次，查询`b`的值）

##### 嵌套作用域

我们说过，作用域就是通过标识名寻找变量的一系列规则。通常情况下有多于一个的作用域需要考虑。

作用域也可以嵌套，就像一个代码块或者函数嵌套在另一个代码块或者函数中一样。所以，如果在当前作用域中找不到需要的变量，那引擎就会到外层作用域中寻找，如此这样下去直到找到需要的变量或者到达最外层作用域。

看下面代码：

```javascript
function foo(a){
  console.log(a + b);
}
var b = 2;
foo(2); //  4
```

`b`的RHS引用在函数`foo`内部是无法查询到的，但是可以在`foo`外围作用域中找到（在这个例子中就是全局作用域）。

所以，回顾一下引擎和作用域之间的对话，我们可以听到：

> 引擎：嗨，`foo`的作用域，你见过`b`这个变量么？我需要一个对它的RHS引用。
> 作用域：没有，没有见过这个变量。你再去问问别人把
> 引擎：嗨，`foo`的外层作用域，你是全局作用域，你见过`b`这个变量么，我需要一个对它的RHS引用。
> 作用域：是的，我见过，给你。

简单的说，在作用域中查找变量的规则是：引擎先在当前正在执行的作用域中查找，如果没有找到，到上层作用域中继续查找，如此查找下去，直到找到变量或者到达外层作用域。到达外层作用域之后查找就会停止，无论有没有找到变量。

##### 用建住来做隐喻

为了形象描述嵌套作用域的查找过程，我们来想象这样一座建筑：

![](./img/201910041438.png)

这栋楼代表着我们代码里的嵌套作用域规则。无论你哪里，楼的第一层代表着当前执行的作用域。楼的顶层代表着全局作用域。

你通过在当前层查找来解析LHS和RHS查询。如果没找到，则乘坐电梯到上一层，继续查找，找不到的话继续再往上一层，如此继续。一旦到达顶层（全局作用域），要么你找到你所需的变量，要么没有，但不管怎样你都不得不停止了。

##### 错误

为什么区分LHS或者RHS这么重要呢？

因为当要查找的变量未声明（没有在任何作用域中找到）时，这两种查询方式有不同的行为。

看下面代码：

```javascript
function foo(a){
  console.log(a + b);
  b = a;
}
foo(2);
```

对变量`b`进行第一次RHS查询时，是找不到`b`这个变量的。也就是说这是一个“未声明（undeclared）”的变量，因为在作用域中没有找到。

如果RHS查询没有在嵌套作用域中找到目标变量，引擎就会抛出一个`ReferenceError`。注意，这个错误类型是`ReferenceError`。

相比之下，如果引擎在执行一个LHS查询，在达到了顶层作用域之后还是没有找到指定的变量，并且代码没有在“严格模式下（Strict Mode[\^note-strictmode]）”下运行，那么全局作用域就会在**全局作用域**中创建一个同名变量，并把它交给引擎。

“在之前是没有这个变量的，但我比较乐于助人，帮你创建了一个，给你。”

在ES5中被添加进来的“严格模式（Strict Mode）”，和正常/宽松/懒惰模式在行为上有很多不一样。其中一个不同点就是严格模式不允许在全局作用域中自动创建变量。在这种情况下，将不会有全局变量因为LHS查询而被自动创建然后交给引擎，引擎此时会和进行RHS查询一样抛出一个`ReferenceError`。

现在，当RHS查询找到了要找的变量，但你准备对变量值做一些不可能的事情，比如将非函数的值当作函数执行，或者读取`null`或者`undefined`的属性引用，引擎就会抛出`TypeError`错误。

`ReferenceError`和作用域解析失败有关，而`TypeError`则意味着作用域解析成功了，但对结果采取了一个非法/不可能的操作。

##### 复习

作用域是一系列关于在何处以及如何查找变量（标识符）的规则。查询有可能是为了给变量赋值，比如LHS引用；又或者仅仅是为了获取变量的值，比如RHS引用。

LHS引用出现在赋值操作中。作用域相关的赋值可以通过 `=` 发生，也可以在给方法传递参数（给参数赋值）的过程中发生。

JavaScript引擎在执行代码前会先编译代码，这样 `var a = 2` 会被分割成两步来实现：

1. 首先，`var a `在当前作用域中声明变量`a`。这在代码执行前一开始就完成的。
2. 然后，`a = 2`查询这个变量（LHS引用），找到后在进行赋值。

所有的LHS和RHS引用查询都是从当前执行作用域开始的，如果有必要（就是说在当前作用域没找到要找的东西），它们会往上到嵌套作用域中查找，每次往上一层作用域，直到最顶层作用域才停下来，无论找到与否。

失败的RHS引用会导致`ReferenceError`错误。非严格模式下，失败的LHS引用会在全局作用域中自动创建同名变量，严格模式下则会抛出`ReferenceError`错误。

##### 小测验答案

````javascript
function foo(a){
  var b = a;
  return a + b;
}
var c = foo(2);
````

1.找出所有LHS查询（总共有3处）

`c = ..`，`a = 2`（参数赋值过程中隐式出现），和`b = ...`

2.找出所有RHS查询（总共有4处）

`foo(2..`，` = a`，`a + ..`和`+ b`

【^note-strictmode】:MDN：[Strict Mode](<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode>)











<https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch1.md>