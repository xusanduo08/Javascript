### 你不知道的JS：作用域和闭包

### 第一章：什么是作用域？

目前几乎所有编程语言都具有将值存储到变量中，在随后的程序中取出或者修改这些值的能力。这种存储值到变量中并且将值取出来的能力给与了程序一种“状态”。

如果没有上面所说的能力，程序依然可以做一些工作，但它们的能力将会受到极大的限制。

上面所说的能力带来了一个问题，那就是：这些变量存储在什么地方？程序是如何发现这些变量以及如何确定何时需要它们的？

回答这些问题需要一系列定义好的规则以便用来在某区域存储变量和在使用时找到这些变量。我们将这一系列规则称为：__作用域__。

那么，这些规则在什么地方、是被如何定义的呢？

#### 编译器理论

根据大家对各种编程语言的了解，有的人觉得这是不证自明的，也有人觉得这非常有趣。尽管Javascript一直被认为是一个“动态的”、“解释型”语言，但事实是Javascript是一个编译型语言。它并不会像其他传统的编译语言一样事先编译好，编译结果也不能在各种分布式系统中完美运行。

但尽管如此，Javascript的引擎还是以一种非常精巧的、难以察觉的方式进行着和传统语言编译器相同的操作。

在传统的编译型语言中，一段代码在被执行前需要经过三个步骤，这三个步骤可以被合称为“编译”：

1. **分词/词法分析**：将一段字符串拆分成有意义的（对语言来说）片段，这些有意义的片段称为token，这个操作称为分词。例如下面一段代码`var a = 2`，这段代码会被拆分成下面几个token：`var`、`a`、`=`、`2`，还有`;`。空格会根据其是否有意义来决定其是否会被保留为一个token。

   **注意**：分词和词法分析之间的区别是微妙的，而且具有学术性质，其中心点在于是否通过有无状态来标识token。简单的说，如果分词器通过有状态的规则去判断`a`是一个独立的token还是另一个token的一部分，那这一过程就是词法分析。



2. **解析**：输入一个toke流（数组），并通过元素嵌套的方式将其转换成一棵树，这棵树代表了程序的语法结构。这这棵树被叫做“AST”（抽象语法树，Abstract Syntax Tree）。

   代码`var a = 2`的语法树以一个被称为`VariableDeclaration`（变量声明）的节点开始，该节点带有一个值为`a`的子节点，称为`Identifier`（标识符）。另一个子节点叫做`AssignmentExpression`（赋值语句），该节点自身带有一个子节点，叫做`NumericLiteral`（数字字面量），其值为`2`。

3. **代码生成**：将抽象语法树转成可执行代码的过程。这一过程中，不同的语言，不同的目标平台，操作会有较大不同。

   所以，与其迷失在细节中，不如简单的说有一种方法能将上面描述`var a = 2`的抽象语法树转换成一串机器可执行的指令并真正的创建一个变量`a`（包括保存在内存中），然后将值存储到`a`中。

   **注意**：关于引擎如何调用系统资源的细节我们不做讨论，我们理所当然的认为引擎有能力去根据需要创建和存储变量。

上面三步只是对编译过程的简单描述。Javascript的引擎和其他语言的一样，编译过程都比上面描述的复杂。例如在解析和代码生成过程中，都会有专门的步骤去优化执行效率，比如合并冗余代码等等。

另外，Javascript的引擎并没有很多的时间去做代码优化，因为它没有专门的构建步骤，这一点和其他编译器不一样。

对于Javascript来说，留给编译步骤的时间只有几微秒，甚至更少，紧接着就是代码执行。为了更快的性能，JS引擎用了各种技巧（比如 JIT，它可以懒编译甚至热编译），当然这不在我们要讨论的“作用域”范围内。

为了简单起见，我们说，任何Javascript代码片段在执行前（通常是_刚好_在执行前）都要被编译。综上，对于`var a = 2`来说，JS编译器会接收这段代码，然后先编译它，再接着就是执行，这两步往往是紧挨着。

#### 理解作用域

我们把作用域的工作想象成一段对话，以此来理解作用域。但是，谁在进行这场对话呢？

##### 角色

先来介绍下在`var a = 2`这段代码中出现的角色，然后再去理解它们的对话：

1. 引擎：负责编译过程的开始和结束，以及代码的执行
2. 编译器：引擎的朋友之一。负责解析和代码生成过程中的所有工作（见上一节）
3. 作用域：引擎的另一个朋友。负责收集和维护由所有声明过的标识符（变量）组成的列表，并且设定了一系列如何在当前代码中获取这些变量的严格的规则

为了能全面的理解Javascript的工作，你需要开始像引擎和它的朋友们那样的思考，问它们问的问题并回答这些问题。

##### 反复

当你看到`var a = 2`这段代码时，你会认为这仅是一段声明而已。但我们的新朋友--引擎并不这么认为。事实上，引擎会认为这是两段不同的声明，一段由编译器在编译阶段处理，一段由引擎在代码执行时处理。

下面，我们来分解下引擎和它的朋友处理`var a = 2`这段代码的过程。

编译器要做的第一件事就是词法分析，将这段代码分成若干个token，然后将这些token解析成抽象语法树。接下来编译器进入代码生成阶段，这一阶段和正常所认为的不一样。

正常你可以会认为编译器生成代码的过程可以被总结成下面一句话：给变量分配内存，标记为`a`，然后将值`2`存储到这个变量中。不幸的是，这种描述并不准确。

编译器实际会进行如下过程：

1. 遇到`var a`代码后，编译器会询问作用域在指定的作用域中，变量`a`是否已经存在，如果已经存在，编译器会忽略当前这个声明并继续往下工作；否则，编译器会让作用域在指定作用域中声明一个新的叫做`a`的变量。
2. 接着编译器生成供引擎执行的代码，让引擎处理`a = 2`这段赋值操作。代码引擎运行时，会先询问作用域，在当前作用域中知否已经存在一个叫做`a`的变量。如果存在，引擎就使用这个已经存在的变量，否则，引擎会去其他地方询问（具体请查看后面的章节）

如果引擎最终找到了这个变量，就会把`2`赋值给它；否则，引擎就会举手然后抛出一个错误。

总结一下：变量的赋值需要两个的操作：首先，编译器声明变量（如果这个变量在当前作用域没有声明过的话），然后在执行代码时，引擎会去作用域中寻找已经声明的变量，如果找到了就将值赋值给它。

##### 编译器术语

我们需要一些编译器术语来方便后面我们的理解。

当引擎在执行编译器生成的代码时，引擎需要去寻找变量`a`是否已经被声明，而这个寻找过程其实就是去询问作用域。引擎采取的查找类型影响着查找结果。

在我们上面的例子中，引擎会执行一次“LHS”去寻找变量`a`（左查询）。另一个类型的查找叫做“RHS”（右查询）。

我打赌你肯定知道“L”和“R”代表的啥，它们分别代表“左边”和“右边”。

那么，这个“左边”、“右边”是相对于谁的“左边”、“右边”呢？**相对于赋值操作**。

换句话说，赋值操作左边存在变量时，会执行一次左查询；赋值操作右边存在变量时，会执行一次右查询。

更进一步的说，右查询有些难以区分，因为它仅仅查询一个变量值是否存在。而左查询则尝试去寻找变量的容器本身，以便进行赋值操作。换句话说，右查询并不是真正意义上的“赋值操作的右边”，更确切的说，“不在赋值操作左边”更合适。

可以这么简单的理解，右查询表示去或者某个值。

继续深入。

看下面代码：

```javascript
console.log(a)
```

上面代码中，指向`a`的引用就是一个RHS引用，因为这地方并没有任何值赋给`a`。相反，我们是在查询并获取`a`的值，然后将获取到的值传递给`console.log(..)`操作。

相反的：

```javascript
a = 2;
```

上面代码中，指向`a`的引用就是一个LHS引用，因为我们并不关心当前`a`的值是啥，我们只是想找到这个变量，然后完成`= 2`的赋值操作。

**注意**：LHS和RHS表示“赋值操作的左右两边”并不能从字面意义上理解成“`=`操作符的左右两边”。赋值有很多种完成方式，所以最好这样理解：赋值的目标需要LHS（左查询），赋值的数据来源需要RHS（右查询）。

考虑下面这段代码，里面包含了LHS和RHS：

```javascript
function foo(a){
	console.log(a); // 2
}
foo(2);
```

上面代码的最后一行出发了函数运行，在触发时执行了一次RHS来获取`foo`的指向----“寻找`foo`的值，找到后u 交给我”。而且，`(...)`表示要执行`foo`，所以它的值应当是个函数。

这地方有个微妙但很重要的赋值，**你发现了么**？

你可能忽略了这段代码里一行实现：`a = 2`。当数值`2`作为参数传入到方法`foo(...)`中时，`2`就会被赋值给形参`a`。为了完成赋值操作，需要执行一次LHS。

代码中也有RHS来查询`a`的数值，查询到的结果传递给了`console.log(...)`。`console.log(...)`的执行需要一个引用。先是一个右查询去查询`console`对象，然后再进行属性解析来判断一下`console`对象是否含有叫`log`的方法。

最后，从概念上来说，在将`2`传入（通过对变量`a`的右查询）到`log(...)`时轮流进行着LHS/RHS。在`log(...)`的原生内部实现中，我们假定它含有形参，在将`2`赋值给第一个参数（或许叫`arg1`）时，进行了一次LHS引用查询。

**注意**：你可能认为从概念上来讲`function foo(a){...}`是一次普通的变量声明和赋值操作，就像`var foo`以及`foo = function(a){...}`一样，。这样做会让你认为函数声明需要一次左查询。

但比较难以察觉的是，在代码生成阶段编译器既进行声明也进行了值的定义，这样引擎在执行代码时，不需要再将函数值赋值给`foo`。因此，把函数声明认为成我们上面讨论的左查询然后赋值的操作并不合适。







<https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch1.md>