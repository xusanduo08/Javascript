### 你不知道的JS：作用域和闭包

### 第一章：什么是作用域？

目前几乎所有编程语言都具有将值存储到变量中，在随后的程序中取出或者修改这些值的能力。这种存储值到变量中并且将值取出来的能力给与了程序一种“状态”。

如果没有上面所说的能力，程序依然可以做一些工作，但它们的能力将会受到极大的限制。

上面所说的能力带来了一个问题，那就是：这些变量存储在什么地方？程序是如何发现这些变量以及如何确定何时需要它们的？

回答这些问题需要一系列定义好的规则以便用来在某区域存储变量和在使用时找到这些变量。我们将这一系列规则称为：__作用域__。

那么，这些规则在什么地方、是被如何定义的呢？

#### 编译器理论

根据大家对各种编程语言的了解，有的人觉得这是不证自明的，也有人觉得这非常有趣。尽管Javascript一直被认为是一个“动态的”、“解释型”语言，但事实是Javascript是一个编译型语言。它并不会像其他传统的编译语言一样事先编译好，编译结果也不能在各种分布式系统中完美运行。

但尽管如此，Javascript的引擎还是以一种非常精巧的、难以察觉的方式进行着和传统语言编译器相同的操作。

在传统的编译型语言中，一段代码在被执行前需要经过三个步骤，这三个步骤可以被合称为“编译”：

1. **分词/词法分析**：将一段字符串拆分成有意义的（对语言来说）片段，这些有意义的片段称为token，这个操作称为分词。例如下面一段代码`var a = 2`，这段代码会被拆分成下面几个token：`var`、`a`、`=`、`2`，还有`;`。空格会根据其是否有意义来决定其是否会被保留为一个token。

   **注意**：分词和词法分析之间的区别是微妙的，而且具有学术性质，其中心点在于是否通过有无状态来标识token。简单的说，如果分词器通过有状态的规则去判断`a`是一个独立的token还是另一个token的一部分，那这一过程就是词法分析。



2. **解析**：输入一个toke流（数组），并通过元素嵌套的方式将其转换成一棵树，这棵树代表了程序的语法结构。这这棵树被叫做“AST”（抽象语法树，Abstract Syntax Tree）。

   代码`var a = 2`的语法树以一个被称为`VariableDeclaration`（变量声明）的节点开始，该节点带有一个值为`a`的子节点，称为`Identifier`（标识符）。另一个子节点叫做`AssignmentExpression`（赋值语句），该节点自身带有一个子节点，叫做`NumericLiteral`（数字字面量），其值为`2`。

3. **代码生成**：将抽象语法树转成可执行代码的过程。这一过程中，不同的语言，不同的目标平台，操作会有较大不同。

   所以，与其迷失在细节中，不如简单的说有一种方法能将上面描述`var a = 2`的抽象语法树转换成一串机器可执行的指令并真正的创建一个变量`a`（包括保存在内存中），然后将值存储到`a`中。

   **注意**：关于引擎如何调用系统资源的细节我们不做讨论，我们理所当然的认为引擎有能力去根据需要创建和存储变量。

上面三步只是对编译过程的简单描述。Javascript的引擎和其他语言的一样，编译过程都比上面描述的复杂。例如在解析和代码生成过程中，都会有专门的步骤去优化执行效率，比如合并冗余代码等等。

另外，Javascript的引擎并没有很多的时间去做代码优化，因为它没有专门的构建步骤，这一点和其他编译器不一样。

对于Javascript来说，留给编译步骤的时间只有几微秒，甚至更少，紧接着就是代码执行。为了更快的性能，JS引擎用了各种技巧（比如 JIT，它可以懒编译甚至热编译），当然这不在我们要讨论的“作用域”范围内。

为了简单起见，我们说，任何Javascript代码片段在执行前（通常是_刚好_在执行前）都要被编译。综上，对于`var a = 2`来说，JS编译器会接收这段代码，然后先编译它，再接着就是执行，这两步往往是紧挨着。





<https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch1.md>