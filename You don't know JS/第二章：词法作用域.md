### 你不知道的JS：作用域和闭包

### 第二章：词法作用域

在第一章，我们将作用域定义为一些列控制引擎如何通过标识符在当前作用域或者任何包含它的嵌套作用域中查找变量的规则。

关于作用域的工作目前有两种比较流行的模型。第一个也是目前为止最流行的，大多数语言用的也都是这个模型，叫做**词法作用域**，我们后面将会仔细研究这个。另一个模型，也有一些语言（比如Bash脚本，Perl中的一些模式等等）在使用，叫做**动态作用域**。

动态作用域会在附录A中有所讲解，在这里我们将其作为和词法作用域的一个对比。JavaScript中使用的就是词法作用域。

#### 词法分析

我们在第一章讨论过，标准语言的编译器工作语言的第一步叫做词法分析（或者说分词）。回想一下，词法分析会检测源码中的字符串。作为一些状态分析的结果，词法分析会赋予tokens以语法意义。

上面的概念提供了理解什么是词法作用域以及命名由来的基础。

词法作用域的定义有些绕，词法作用域是指在词法分析阶段定义的作用域。换句话说，词法作用域取决于你将变量和块级作用域写在何处，因此，在词法分析器分析代码的过程中，作用域是固定不变的（大多数情况下）。

**注意**：后面我们将介绍几种欺骗词法作用域的方法，这些方法可以在词法分析阶段之后修改词法作用域，但它们都有一些难理解。~~比较推崇的做法是仅在词法阶段也就是代码编写阶段定义词法作用域~~保持词法作用域与书写时的词法关系一致是一个比较推崇的做法。

看下面一段代码：

```javascript
function foo(a){
  var b = a * 2;
  function bar(c){
    console.log(a, b, c);
  }
  bar(b * 3);
}
foo(2); // 2 4 12
```

上面代码中有三层嵌套作用域。来将它们想象成相互包含的气泡：

![](./img/201910052203.png)

**气泡1**：包含全局作用域，其中只有一个标识符：`foo`。

**气泡2**：包含`foo`作用域，其中含有三个标识符：`a`、`bar`和`b`。

**气泡3**：包含`bar`作用域，其中只有一个标识符：`c`。

作用域气泡由各自作用域块被编写的位置所定义，这些作用域块之间~~相互~~逐级嵌套。下一章我们将会讨论~~不同的作用域~~作用域的不同组成，但目前我们仅假设每个函数会创建一个新的作用域气泡。

`bar`的作用域气泡完全被`foo`的作用域气泡所包含，因为（仅因为）我们就是在`foo`里定义的函数`bar`。

注意到这些嵌套气泡是被严格嵌套的。我们没有讨论气泡可以跨域边界的文恩图（Venn diagrams）。换句话说，作用域气泡不可能同时（部分）存在于两个外层作用域气泡中，就像没有函数可以部分的同时存在于两个父级函数中。

##### 查找

作用域气泡的结构和相对位置告诉了引擎寻找标识符时需要查找的地方。

在上面的代码片段中，引擎执行`console.log(...)`这段代码，并且去寻找`a`，`b`，和`c`三个变量引用。查找开始于最内层的作用域气泡，也就是`bar(...)`函数。在这个函数里面找不到变量`a`，所以继续往上一层，到最近的作用域气泡中也就是`foo(...)`中继续查找。在`foo(...)`中找到了`a`，所以引擎就会取这里`a`的值来使用。`b`的寻找过程和`a`一样。至于`c`，在`bar(...)`中就能找到。

如果在`bar(...)`和`foo(...)`中都含有变量`c`，则`console.log(...)`在找到`bar(...)`中的变量`c`后就会停止查找，不会再去查找`foo(...)`中的`c`，然后使用当前查找到的`c`执行代码。

**找到第一个匹配后，作用域就会停止查找**。在嵌套作用域的不同层级可以定义同名的标识符，这种操作会引起“遮蔽效应”（内部变量会遮蔽外部变量）。抛开遮蔽效应，作用域总是从当前正在执行的作用域开始查找，逐层向上，直到找到第一个匹配，然后停止。

**注意**：全局变量会自动成为全局对象（浏览器的`window`，等等）的属性，所以还可以通过对全局对象的属性引用获取一个全局变量，而不仅仅是通过变量的词法名称。

```javascript
window.a
```

当全局变量被遮蔽的时候，可以通过上面的方法来获取全局变量。但是如果遮蔽的不是全局变量，那就无法获取了。

无论函数在何处被调用，如何被调用，函数的词法作用域**仅**由它们被声明的位置所定义。

词法作用域查找过程仅处理一级标识符，比如`a`，`b`，或者`c`。如果代码中出现`foo.bar.baz`这样的引用，那么词法作用域会去查找`foo`标识符，找到后，属性访问规则就会接管对`bar`和`baz`属性的访问。

#### 欺骗词法作用域

词法作用域仅由代码编写阶段函数被声明的位置所决定，那么如何实现在运行时修改（或者说欺骗）词法作用域呢？

JavaScript对此有两中机制，但社区中大部分都认为这两种机制都是难以理解的，并且不推荐这种做法。反对这种做法最重要的一点理由是：**欺骗作用域会引起性能问题**。

在解释性能问题之前，我们先看下这两种机制是如何工作的。

##### `eval`

`eval(...)`方法接收一段字符串作为参数，然后把这段字符串当成一段本来就存在于当前`eval()`被执行位置的代码来处理。换句话说，你可以在代码中用编程的方式生成代码，然后可以把这段代码当成在编写阶段就存在那样执行。

从上面的解析来看，`eval(...)`是如何让你能修改词法作用域的应该很清楚了：欺骗和假装代码在编写阶段（或者说词法阶段）就已经存在了。

在执行`eval(...)`后面的代码时，引擎不会知道也不会关心前一段代码是动态插入的并且修改了词法作用域。引擎只会像往常一样去执行它的词法作用域查找工作。

看下面的代码：

```javascript
function foo(str, a){
  eval(str); // cheating!
  console.log(a, b);
}
var b = 2;
foo('var b = 3;', 1);
```

当`eval(...)`执行时，`var b = 3`这段字符串会被当成是一直存在于那里的一段代码。这段代码中声明了一个新的变量`b`，修改了`foo(...)`已经存在的词法作用域。事实上，根据前面讲的，这段代码在`foo(...)`内部创建了一个变量`b`，遮蔽了外部（全局）作用域中的`b。`

当`console.log(...)`这段代码执行时，`a`和`b`两个变量都会在`foo(...)`内部被找到，而外部的变量`b`则不会。所以代码最终打印`1 3`而不是一般情况下的`1 2`。

**注意**：在上面的例子中，为了简便起见，传入的字符串“代码”是固定的文本。但实际是可以基于我们的代码逻辑用编程的思想来将字符拼接到一起生成要添加的内容。`eval(...)`一般用来执行动态生成的代码，但动态执行来自字符串的代码与直接在程序中写好这段代码相比没有任何直接的好处。

默认情况下，如果`eval(...)`中执行的字符串包含有多个声明（变量或者函数），这会修改`eval(...)`所处的词法作用域。从技术上来讲，`eval(...)`可以通过各种技巧间接的触发（超出我们的讨论范围了），并使其在全局作用域中执行并修改全局作用域。但不管如何触发，`eval(...)`都能在运行时修改词法作用域。

**注意**：在严格模式下，`eval()`在运行时有其自己的词法作用域，也就是说`eval()`中声明的东西不会影响包裹它的作用域。

```javascript
function foo(str){
  'use strict';
  eval(str);
  console.log(a); // ReferenceError: a is not defined
}
foo('var a = 2');
```

JavaScript中还有一些和`eval(...)`很相似的功能。`setTimeout(...)`和`setInterval(...)`都能接收一个字符串作为它们各自的第一个参数，这个字符串会被`eval()`认为成是动态生成的函数。这种做法比较落后，而且将会被遗弃，所以不要这么做！

构造函数`new Function(...)`的行为也很类似，它的**最后**一个参数是一个字符串，这段字符串会被动态的解析成函数（前面的参数将会是新生成的函数的形参）。这种构造函数的语法比`eval(...)`稍微安全些，但也要尽量避免在代码使用。

动态生成代码的例子在程序中非常少见，因为它带来的性能问题远超过它带来的好处。















原文地址：<https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch2.md>