### 你不知道的JS：作用域和闭包

### 第二章：词法作用域

在第一章，我们将作用域定义为一些列控制引擎如何通过标识符在当前作用域或者任何包含它的嵌套作用域中查找变量的规则。

关于作用域的工作目前有两种比较流行的模型。第一个也是目前为止最流行的，大多数语言用的也都是这个模型，叫做**词法作用域**，我们后面将会仔细研究这个。另一个模型，也有一些语言（比如Bash脚本，Perl中的一些模式等等）在使用，叫做**动态作用域**。

动态作用域会在附录A中有所讲解，在这里我们将其作为和词法作用域的一个对比。JavaScript中使用的就是词法作用域。

#### 词法分析

我们在第一章讨论过，标准语言的编译器工作语言的第一步叫做词法分析（或者说分词）。回想一下，词法分析会检测源码中的字符串。作为一些状态分析的结果，词法分析会赋予tokens以语法意义。

上面的概念提供了理解什么是词法作用域以及命名由来的基础。

词法作用域的定义有些绕，词法作用域是指在词法分析阶段定义的作用域。换句话说，词法作用域取决于你将变量和块级作用域写在何处，因此，在词法分析器分析代码的过程中，作用域是固定不变的（大多数情况下）。

**注意**：后面我们将介绍几种欺骗词法作用域的方法，这些方法可以在词法分析阶段之后修改词法作用域，但它们都有一些难理解。~~比较推崇的做法是仅在词法阶段也就是代码编写阶段定义词法作用域~~保持词法作用域与书写时的词法关系一致是一个比较推崇的做法。

看下面一段代码：

```javascript
function foo(a){
  var b = a * 2;
  function bar(c){
    console.log(a, b, c);
  }
  bar(b * 3);
}
foo(2); // 2 4 12
```

上面代码中有三层嵌套作用域。来将它们想象成相互包含的气泡：

![](./img/201910052203.png)

**气泡1**：包含全局作用域，其中只有一个标识符：`foo`。

**气泡2**：包含`foo`作用域，其中含有三个标识符：`a`、`bar`和`b`。

**气泡3**：包含`bar`作用域，其中只有一个标识符：`c`。

作用域气泡由各自作用域块被编写的位置所定义，这些作用域块之间~~相互~~逐级嵌套。下一章我们将会讨论~~不同的作用域~~作用域的不同组成，但目前我们仅假设每个函数会创建一个新的作用域气泡。

`bar`的作用域气泡完全被`foo`的作用域气泡所包含，因为（仅因为）我们就是在`foo`里定义的函数`bar`。

注意到这些嵌套气泡是被严格嵌套的。我们没有讨论气泡可以跨域边界的文恩图（Venn diagrams）。换句话说，作用域气泡不可能同时（部分）存在于两个外层作用域气泡中，就像没有函数可以部分的同时存在于两个父级函数中。

##### 查找

作用域气泡的结构和相对位置告诉了引擎寻找标识符时需要查找的地方。

在上面的代码片段中，引擎执行`console.log(...)`这段代码，并且去寻找`a`，`b`，和`c`三个变量引用。查找开始于最内层的作用域气泡，也就是`bar(...)`函数。在这个函数里面找不到变量`a`，所以继续往上一层，到最近的作用域气泡中也就是`foo(...)`中继续查找。在`foo(...)`中找到了`a`，所以引擎就会取这里`a`的值来使用。`b`的寻找过程和`a`一样。至于`c`，在`bar(...)`中就能找到。

如果在`bar(...)`和`foo(...)`中都含有变量`c`，则`console.log(...)`在找到`bar(...)`中的变量`c`后就会停止查找，不会再去查找`foo(...)`中的`c`，然后使用当前查找到的`c`执行代码。

**找到第一个匹配后，作用域就会停止查找**。在嵌套作用域的不同层级可以定义同名的标识符，这种操作会引起“遮蔽效应”（内部变量会遮蔽外部变量）。抛开遮蔽效应，作用域总是从当前正在执行的作用域开始查找，逐层向上，直到找到第一个匹配，然后停止。

**注意**：全局变量会自动成为全局对象（浏览器的`window`，等等）的属性，所以还可以通过对全局对象的属性引用获取一个全局变量，而不仅仅是通过变量的词法名称。

```javascript
window.a
```

当全局变量被遮蔽的时候，可以通过上面的方法来获取全局变量。但是如果遮蔽的不是全局变量，那就无法获取了。

无论函数在何处被调用，如何被调用，函数的词法作用域**仅**由它们被声明的位置所定义。

词法作用域查找过程仅处理一级标识符，比如`a`，`b`，或者`c`。如果代码中出现`foo.bar.baz`这样的引用，那么词法作用域会去查找`foo`标识符，找到后，属性访问规则就会接管对`bar`和`baz`属性的访问。

#### 欺骗词法作用域

词法作用域仅由代码编写阶段函数被声明的位置所决定，那么如何实现在运行时修改（或者说欺骗）词法作用域呢？

JavaScript对此有两中机制，但社区中大部分都认为这两种机制都是难以理解的，并且不推荐这种做法。反对这种做法最重要的一点理由是：**欺骗作用域会引起性能问题**。

在解释性能问题之前，我们先看下这两种机制是如何工作的。

##### `eval`

`eval(...)`方法接收一段字符串作为参数，然后把这段字符串当成一段本来就存在于当前`eval()`被执行位置的代码来处理。换句话说，你可以在代码中用编程的方式生成代码，然后可以把这段代码当成在编写阶段就存在那样执行。

从上面的解析来看，`eval(...)`是如何让你能修改词法作用域的应该很清楚了：欺骗和假装代码在编写阶段（或者说词法阶段）就已经存在了。

在执行`eval(...)`后面的代码时，引擎不会知道也不会关心前一段代码是动态插入的并且修改了词法作用域。引擎只会像往常一样去执行它的词法作用域查找工作。

看下面的代码：

```javascript
function foo(str, a){
  eval(str); // cheating!
  console.log(a, b);
}
var b = 2;
foo('var b = 3;', 1);
```

当`eval(...)`执行时，`var b = 3`这段字符串会被当成是一直存在于那里的一段代码。这段代码中声明了一个新的变量`b`，修改了`foo(...)`已经存在的词法作用域。事实上，根据前面讲的，这段代码在`foo(...)`内部创建了一个变量`b`，遮蔽了外部（全局）作用域中的`b。`

当`console.log(...)`这段代码执行时，`a`和`b`两个变量都会在`foo(...)`内部被找到，而外部的变量`b`则不会。所以代码最终打印`1 3`而不是一般情况下的`1 2`。

**注意**：在上面的例子中，为了简便起见，传入的字符串“代码”是固定的文本。但实际是可以基于我们的代码逻辑用编程的思想来将字符拼接到一起生成要添加的内容。`eval(...)`一般用来执行动态生成的代码，但动态执行来自字符串的代码与直接在程序中写好这段代码相比没有任何直接的好处。

默认情况下，如果`eval(...)`中执行的字符串包含有多个声明（变量或者函数），这会修改`eval(...)`所处的词法作用域。从技术上来讲，`eval(...)`可以通过各种技巧间接的触发（超出我们的讨论范围了），并使其在全局作用域中执行并修改全局作用域。但不管如何触发，`eval(...)`都能在运行时修改词法作用域。

**注意**：在严格模式下，`eval()`在运行时有其自己的词法作用域，也就是说`eval()`中声明的东西不会影响包裹它的作用域。

```javascript
function foo(str){
  'use strict';
  eval(str);
  console.log(a); // ReferenceError: a is not defined
}
foo('var a = 2');
```

JavaScript中还有一些和`eval(...)`很相似的功能。`setTimeout(...)`和`setInterval(...)`都能接收一个字符串作为它们各自的第一个参数，这个字符串会被`eval()`认为成是动态生成的函数。这种做法比较落后，而且将会被遗弃，所以不要这么做！

构造函数`new Function(...)`的行为也很类似，它的**最后**一个参数是一个字符串，这段字符串会被动态的解析成函数（前面的参数将会是新生成的函数的形参）。这种构造函数的语法比`eval(...)`稍微安全些，但也要尽量避免在代码使用。

动态生成代码的例子在程序中非常少见，因为它带来的性能问题远超过它带来的好处。

##### `with`

JavaScript中另一个让人头疼的（现在已经被废弃）可以欺骗词法作用域的功能是`with`关键字。解释`with`有很多方法，我选择从它如何与词法作用域交互以及如何影响词法作用域的角度来解释。

`with`可以看成是访问某一对象的多个属性引用的快捷方式，可以不用每次都重复的获取对象引用本身。

例如：

```javascript
var obj = {
  a: 1, 
  b: 2, 
  c: 3
}

// more 'tedious' to repeat 'obj'
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 'easier' short-hand
with(obj){
  a = 3;
  b = 4;
  c = =5;
}
```

但是，`with`的用处不仅体现在访问对象属性上。看下面代码：

```javascript
function foo(obj){
  with(obj){
    a = 2;
  }
}

var o1 = {
  a: 3;
}
var o2 = {
  b: 3
}
foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // a泄露到全局作用域中了
```

上面的代码中，我们创建了两个对象`o1`和`o2`。其中一个含有`a`属性，另一个没有。`foo(...)`接收一个对象引用作为入参，并在这个对象引用上调用`with(obj){...}`。在`with`内部，我们访问了变量`a`的词法引用——其实就是LHS引用——并将其赋值为`2`。

当将`o1`传入到函数中时，`a = 2`这段赋值会找到`o1.a`这个属性，并将其赋值为`2`。接下来的`console.log(o1.a)`这段代码可以反映出相关改变。当把`o2`传入到函数中时，因为`o2`没有`a`这个属性，也没有为`o2`创建这个属性，所以`o2.a`依然是`undefined`。

通过上面最后一段代码，我们能察觉到一个奇怪的副作用，`a = 2`这段赋值创建了一个全局变量`a`，这是怎么发生的？

`with`操作接收一个对象，这个对象可能有零个或者多个属性。`with`会将这个对象当成是一个完全独立的词法作用域，对象的属性会被当成是此作用域中已声明过的标识符。

**注意**：即便`with`会将对象当作一个词法作用域，但`with`代码块中正常的`var`声明并不会被限制在`with`代码块内部，而是会被放到包含`with`的函数作用域中。

`eval(...)`接收一个含有一个或多个声明的字符串代码，修改已经存在的作用域，而`with`则是利用传入的对象凭空创建了一个完全新的作用域。

这样理解，`with`接收我们传入的`o1`，然后创建了一个叫做`o1`的作用域，这个作用域含有一个和`o1.a`属性相对应的“标识符”。但当`with`使用`o2`对象创建`o2`作用域时，它就没有`a`这个“标识符”了，因为代码中要对这个标识符进行赋值，所以接下来就是根据LHS的规则去查找这个标识符（见第一章）。

如果`o2`作用域中没有变量`a`，`foo(...)`中也没有，甚至全局作用域中也没有，那当`a = 2`执行时，一个全局变量就会被自动创建（因为不是在严格模式下）。

将对象变成一个作用域，并将属性解析成作用域中的标识符，这个看起来有些令人费解。但这是我能想出的对我们看到的结果的最清晰的解释了。

**注意**：为了防止滥用，严格模式对`eval(...)`和`with`都有一定的限制：`with`会被彻底禁用；除了保留其核心功能外，各种对`eval(...)`的使用也是不允许的。













原文地址：<https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch2.md>