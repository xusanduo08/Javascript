##你不知道的JS：作用域和闭包

##第三章：函数和块作用域

根据第二章的内容我们知道，作用域由一些“泡泡”组成，这些泡泡相当于容器，在其中可以声明标识符（变量，函数）。泡泡逐级嵌套，并且这种嵌套关系是在代码编写阶段就被确定的。

现在的问题是，泡泡是由什么创建的呢？只有函数可以么？JavaScript中的其他结构可以创建么？

###函数中的作用域

上面问题的一个比较通行的答案是：JavaScript含有函数级作用域。也就是说，每个函数都会为自己创建一个作用域气泡，而其他结构则不能创建作用域气泡。在接下来我们将会看到，上面的回答并不准确。

我们先来解释下函数级作用域和实现。

看下面的代码：

```javascript
function foo(a){
  var b = 2;
  function bar(){
    //..
  }
  // more code
  var c = 3;
}
```

在上面的代码中，`foo(...)`的作用域中包含`a`，`b`和`bar`三个标识符。**无论**在作用域的何处做标识符声明，声明的函数或者变量都属于包含它们的作用域。后面的章节我们会解释其中的原理。

`bar(...)`拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，并且其中只有一个标识符：`foo`。

`a`，`b`，和`c`都属于`foo(...)`的作用域气泡，所以在`foo(...)`外部是无法获取到这三个标识符的。也就是说，下面的代码会抛出`ReferenceError`，因为在全局作用域下访问不到这几个标识符：

```javascript
bar(); // fails
console.log(a, b, c); // all 3 fail
```

在`foo(...)`内部这几个标识符（`a`，`b`，`c`，`foo`和`bar`）都是可以获取到的，在`bar(...)`内部也可以获取到（假设在`bar(...)`内部没有针对这几个标识符做遮蔽）。

函数作用域可以理解为函数内所有的变量都属于函数，在函数的整个函数体内都可以使用（甚至在所嵌套的作用域中也可以）。这种设计非常拥有，可以充分利用JavaScript变量的动态性来根据需要存储不同类型的变量值。

另一方面，如果在使用时不加小心，跨越整个作用域存在的变量可能会引起一些意想不到的问题。

###隐藏内部实现

一般我们对函数的认识是，先声明一个函数，然后在函数内部添加代码。但反过来想也同样很有用：任意挑选一段你写的代码，然后用一个函数声明包裹这段代码，从这个角度看，相当于是将代码藏了起来。

上面提到的操作最终结果是创建了一个作用域气泡包裹在代码周围，这也意味着，代码中标识符（变量或者函数）都将被绑定在包围它们的这个新函数的作用域中，而不是之前包围它们的作用域。换句话说，你可以通过把变量和函数包裹在一个函数的作用域中来达到隐藏它们的目的。

为什么说“隐藏”变量和函数是一个有用的技能呢？

有很多原因驱使着这种基于作用域的隐藏。这种操作更多源自于“最小权限原则”这一软件设计原则，有时候也叫“最小授权原则”或者“最小暴露原则”。这一设计原则是说，在软件设计中，应该只暴露最小且必要的内容，其他的东西要隐藏在内部，比如某个模块或对象的API。

从这一原则可以延伸出如何选择作用域来包裹变量和函数。如果变量和方法都放到全局作用域中，那自然所有的嵌套作用域都可以访问到它们，但这种操作违反了“最小权限”这一原则，并且（很可能）暴露了很多本应该被设为私有的变量和函数，正常情况下，这些变量和函数是不能被获取到的。

例如：

```javascript
function doSomething(a){
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}
function doSomethingElse(a){
  return a - 1;
}
var b;
doSomething(2); // 15
```

在上面的代码中，变量`b`和方法`doSomethingElse(...)`可以看成是`doSomething(...)`如何工作的“私有”内容。给外围作用域访问`doSomethingElse(...)`的权限不仅是没必要的，更是“危险”的，在这种情况下，方法可能会被有意或者无意的调用，而这可能已经超出了`doSomething(...)`假设的前提条件。

比较合适的设计是将这些私有内容放到`doSomething(...)`内部，比如：

```javascript
function doSomething(a){
  function doSomethingElse(a){
    return a - 1;
  }
  var b;
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}
doSomething(2); // 15
```

现在，`b`和`doSomethingElse(...)`在外部作用域中已经无法获取到了，它们目前只处于`doSomething(...)`的控制之下。函数的功能和结果没有受到影响，但这种设计能让私有变量保持私有，这种做法是受推荐的。

####避免冲突

将变量和函数隐藏在作用域中的另一个好处是可以避免两个同名但用处不同的标识符无意中发生冲突。这种冲突通常会导致某个值被覆盖。

例如：

```javascript
function foo(){
  function bar(a){
    i = 3; // 改变了for循环中 `i`的值
    console.log(a + i);
  }
  for(var i = 0; i < 10; i++){
    bar(i * 2); // 不好，无限循环
  }
}
foo();
```

`bar(...)`方法中的赋值操作`i = 3`会重写for循环中声明的处于`foo(...)`中的`i`。因为`i`被设置成了固定值`3`，一直都满足`< 10`这个条件，所以就变成了一个无限循环。

无论`bar(...)`中赋值的标识符名称是什么，都需要声明成本地变量才行。`var i = 3`（会为`i`创建一个之前提到过的“遮蔽变量”）就可以解决上面的问题。另一个方法是使用完全不同的标识符名称，比如`var j = 3`。但你的软件设计可能会自然而然的要求使用同名的标识符，在这种情况下使用作用域来“隐藏”声明是你最好且唯一的选择。

##### 全局命名空间

如果代码中引入的代码库没有对它们内部/私有的变量和方法进行隐藏的话，会很容易导致变量冲突。

代码库通常会在全局作用域中声明一个有效且独一无二的变量，一般为一个对象，这个对象会被用作这个库的命名空间。库中要暴露的功能都会作为这个对象的属性暴露出来，而不是暴露为一个顶级词法标识符。

例如：

```javascript
var MyReallyCoolLibrary = {
  awesome: 'stuff',
  doSomething: function (){
    //..
  }.
  doAnotherThing: function(){
    //..
  }
}
```

##### 模块管理

还可以使用比较流行的模块管理方法--基于各种依赖管理--来避免冲突。使用这种方法，工具库的标识符无需再添加到全局作用域中，取而代之的是通过依赖管理机制，所需要的库的标识符都将会被清晰的引入到指定的作用域中。

有一点要明确，这种方法并没有使用超出词法作用域规则之外的“魔法”。它们只是使用作用域规则禁止任何标识符注入到共享作用域中，使这些标识符保留在自己的私有，没有冲突的作用域中，这样避免了意外的作用域冲突。

使用模块管理后，你就可以通过依赖来获取引用结果，代码也可以更内聚。查看第五章获取更多关于模块模式的信息。

### 函数作用域

我们知道在代码外面包裹一个函数可以有效的将变量或者函数声明限制在函数内部。比如下面代码：

```javascript
var a = 2;
function foo(){ // <-- insert this
  var a = 3;
  console.log(a); // 3
} // <-- and this
foo();// <-- and this
console.log(a); // 2
```

虽然这种方法效果很好，但却不是最理想的方法。这种方法会引起几个问题。首先我们需要声明一个函数`foo()`，也就是说`foo`这个标识符本身就污染了外围作用域（这里是全局作用域）。此外，我们还要手动的去执行`foo()`方法这样它内部的代码才能执行。

如果这个方法不需要名字（或者名字不会污染外围作用域）就好了，如果再能自动执行就更好了。

幸运的是，JavaScript中提供了解决这两个问题的方法。

```javascript
var a = 2;
(function foo(){ // <--insert this
  var a = 3;
  console.log(a); // 3
})(); // <-- and this
console.log(a); // 2
```

我们来一步步看这其中的原理。

首先，函数声明的开头是`(function...`而不是`function...`，这点差别虽然看起来很小，但实际造成的改变很大。现在这代码已经不是个标准的函数声明了，而是个函数表达式。

**注意**：区分声明还是表达式的最简单的方法是注意`function`关键字在声明中（不只是一行代码，而应该是整个声明）的位置。如果`function`关键字在声明的最开始，则这是个函数声明；否则就是个函数表达式。







