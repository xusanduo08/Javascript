### 你不知道的JS：作用域和闭包

### 第三章：函数和块作用域

根据第二章的内容我们知道，作用域由一些“泡泡”组成，这些泡泡相当于容器，在其中可以声明标识符（变量，函数）。泡泡逐级嵌套，并且这种嵌套关系是在代码编写阶段就被确定的。

现在的问题是，泡泡是由什么创建的呢？只有函数可以么？JavaScript中的其他结构可以创建么？

#### 函数作用域

上面问题的一个比较通行的答案是：JavaScript含有函数级作用域。也就是说，每个函数都会为自己创建一个作用域气泡，而其他结构则不能创建作用域气泡。在接下来我们将会看到，上面的回答并不准确。

我们先来解释下函数级作用域和实现。

看下面的代码：

```javascript
function foo(a){
  var b = 2;
  function bar(){
    //..
  }
  // more code
  var c = 3;
}
```

在上面的代码中，`foo(...)`的作用域中包含`a`，`b`和`bar`三个标识符。**无论**在作用域的何处做标识符声明，声明的函数或者变量都属于包含它们的作用域。后面的章节我们会解释其中的原理。

`bar(...)`拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，并且其中只有一个标识符：`foo`。

`a`，`b`，和`c`都属于`foo(...)`的作用域气泡，所以在`foo(...)`外部是无法获取到这三个标识符的。也就是说，下面的代码会抛出`ReferenceError`，因为在全局作用域下访问不到这几个标识符：

```javascript
bar(); // fails
console.log(a, b, c); // all 3 fail
```

在`foo(...)`内部这几个标识符（`a`，`b`，`c`，`foo`和`bar`）都是可以获取到的，在`bar(...)`内部也可以获取到（假设在`bar(...)`内部没有针对这几个标识符做遮蔽）。

函数作用域可以理解为函数内所有的变量都属于函数，在函数的整个函数体内都可以使用（甚至在所嵌套的作用域中也可以）。这种设计非常拥有，可以充分利用JavaScript变量的动态性来根据需要存储不同类型的变量值。

另一方面，如果在使用时不加小心，跨越整个作用域存在的变量可能会引起一些意想不到的问题。







