## 你不知道的JS：作用域和闭包

## 第三章：函数和块作用域

根据第二章的内容我们知道，作用域由一些“泡泡”组成，这些泡泡相当于容器，在其中可以声明标识符（变量，函数）。泡泡逐级嵌套，并且这种嵌套关系是在代码编写阶段就被确定的。

现在的问题是，泡泡是由什么创建的呢？只有函数可以么？JavaScript中的其他结构可以创建么？

### 函数中的作用域

上面问题的一个比较通行的答案是：JavaScript含有函数级作用域。也就是说，每个函数都会为自己创建一个作用域气泡，而其他结构则不能创建作用域气泡。在接下来我们将会看到，上面的回答并不准确。

我们先来解释下函数级作用域和实现。

看下面的代码：

```javascript
function foo(a){
  var b = 2;
  function bar(){
    //..
  }
  // more code
  var c = 3;
}
```

在上面的代码中，`foo(...)`的作用域中包含`a`，`b`和`bar`三个标识符。**无论**在作用域的何处做标识符声明，声明的函数或者变量都属于包含它们的作用域。后面的章节我们会解释其中的原理。

`bar(...)`拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，并且其中只有一个标识符：`foo`。

`a`，`b`，和`c`都属于`foo(...)`的作用域气泡，所以在`foo(...)`外部是无法获取到这三个标识符的。也就是说，下面的代码会抛出`ReferenceError`，因为在全局作用域下访问不到这几个标识符：

```javascript
bar(); // fails
console.log(a, b, c); // all 3 fail
```

在`foo(...)`内部这几个标识符（`a`，`b`，`c`，`foo`和`bar`）都是可以获取到的，在`bar(...)`内部也可以获取到（假设在`bar(...)`内部没有针对这几个标识符做遮蔽）。

函数作用域可以理解为函数内所有的变量都属于函数，在函数的整个函数体内都可以使用（甚至在所嵌套的作用域中也可以）。这种设计非常拥有，可以充分利用JavaScript变量的动态性来根据需要存储不同类型的变量值。

另一方面，如果在使用时不加小心，跨越整个作用域存在的变量可能会引起一些意想不到的问题。

### 隐藏内部实现

一般我们对函数的认识是，先声明一个函数，然后在函数内部添加代码。但反过来想也同样很有用：任意挑选一段你写的代码，然后用一个函数声明包裹这段代码，从这个角度看，相当于是将代码藏了起来。

上面提到的操作最终结果是创建了一个作用域气泡包裹在代码周围，这也意味着，代码中标识符（变量或者函数）都将被绑定在包围它们的这个新函数的作用域中，而不是之前包围它们的作用域。换句话说，你可以通过把变量和函数包裹在一个函数的作用域中来达到隐藏它们的目的。

为什么说“隐藏”变量和函数是一个有用的技能呢？

有很多原因驱使着这种基于作用域的隐藏。这种操作更多源自于“最小权限原则”这一软件设计原则，有时候也叫“最小授权原则”或者“最小暴露原则”。这一设计原则是说，在软件设计中，应该只暴露最小且必要的内容，其他的东西要隐藏在内部，比如某个模块或对象的API。

从这一原则可以延伸出如何选择作用域来包裹变量和函数。如果变量和方法都放到全局作用域中，那自然所有的嵌套作用域都可以访问到它们，但这种操作违反了“最小权限”这一原则，并且（很可能）暴露了很多本应该被设为私有的变量和函数，正常情况下，这些变量和函数是不能被获取到的。

例如：

```javascript
function doSomething(a){
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}
function doSomethingElse(a){
  return a - 1;
}
var b;
doSomething(2); // 15
```

在上面的代码中，变量`b`和方法`doSomethingElse(...)`可以看成是`doSomething(...)`如何工作的“私有”内容。给外围作用域访问`doSomethingElse(...)`的权限不仅是没必要的，更是“危险”的，在这种情况下，方法可能会被有意或者无意的调用，而这可能已经超出了`doSomething(...)`假设的前提条件。

比较合适的设计是将这些私有内容放到`doSomething(...)`内部，比如：

```javascript
function doSomething(a){
  function doSomethingElse(a){
    return a - 1;
  }
  var b;
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}
doSomething(2); // 15
```

现在，`b`和`doSomethingElse(...)`在外部作用域中已经无法获取到了，它们目前只处于`doSomething(...)`的控制之下。函数的功能和结果没有受到影响，但这种设计能让私有变量保持私有，这种做法是受推荐的。

#### 避免冲突

将变量和函数隐藏在作用域中的另一个好处是可以避免两个同名但用处不同的标识符无意中发生冲突。这种冲突通常会导致某个值被覆盖。

例如：

```javascript
function foo(){
  function bar(a){
    i = 3; // 改变了for循环中 `i`的值
    console.log(a + i);
  }
  for(var i = 0; i < 10; i++){
    bar(i * 2); // 不好，无限循环
  }
}
foo();
```

`bar(...)`方法中的赋值操作`i = 3`会重写for循环中声明的处于`foo(...)`中的`i`。因为`i`被设置成了固定值`3`，一直都满足`< 10`这个条件，所以就变成了一个无限循环。

无论`bar(...)`中赋值的标识符名称是什么，都需要声明成本地变量才行。`var i = 3`（会为`i`创建一个之前提到过的“遮蔽变量”）就可以解决上面的问题。另一个方法是使用完全不同的标识符名称，比如`var j = 3`。但你的软件设计可能会自然而然的要求使用同名的标识符，在这种情况下使用作用域来“隐藏”声明是你最好且唯一的选择。

##### 全局命名空间

如果代码中引入的代码库没有对它们内部/私有的变量和方法进行隐藏的话，会很容易导致变量冲突。

代码库通常会在全局作用域中声明一个有效且独一无二的变量，一般为一个对象，这个对象会被用作这个库的命名空间。库中要暴露的功能都会作为这个对象的属性暴露出来，而不是暴露为一个顶级词法标识符。

例如：

```javascript
var MyReallyCoolLibrary = {
  awesome: 'stuff',
  doSomething: function (){
    //..
  }.
  doAnotherThing: function(){
    //..
  }
}
```

##### 模块管理

还可以使用比较流行的模块管理方法--基于各种依赖管理--来避免冲突。使用这种方法，工具库的标识符无需再添加到全局作用域中，取而代之的是通过依赖管理机制，所需要的库的标识符都将会被清晰的引入到指定的作用域中。

有一点要明确，这种方法并没有使用超出词法作用域规则之外的“魔法”。它们只是使用作用域规则禁止任何标识符注入到共享作用域中，使这些标识符保留在自己的私有，没有冲突的作用域中，这样避免了意外的作用域冲突。

使用模块管理后，你就可以通过依赖来获取引用结果，代码也可以更内聚。查看第五章获取更多关于模块模式的信息。

### 函数作用域

我们知道在代码外面包裹一个函数可以有效的将变量或者函数声明限制在函数内部。比如下面代码：

```javascript
var a = 2;
function foo(){ // <-- insert this
  var a = 3;
  console.log(a); // 3
} // <-- and this
foo();// <-- and this
console.log(a); // 2
```

虽然这种方法效果很好，但却不是最理想的方法。这种方法会引起几个问题。首先我们需要声明一个函数`foo()`，也就是说`foo`这个标识符本身就污染了外围作用域（这里是全局作用域）。此外，我们还要手动的去执行`foo()`方法这样它内部的代码才能执行。

如果这个方法不需要名字（或者名字不会污染外围作用域）就好了，如果再能自动执行就更好了。

幸运的是，JavaScript中提供了解决这两个问题的方法。

```javascript
var a = 2;
(function foo(){ // <--insert this
  var a = 3;
  console.log(a); // 3
})(); // <-- and this
console.log(a); // 2
```

我们来一步步看这其中的原理。

首先，函数声明的开头是`(function...`而不是`function...`，这点差别看起来虽然很小，但实际造成的改变很大。现在这代码已经不是个标准的函数声明了，而是个函数表达式。

**注意**：区分声明还是表达式的最简单的方法是注意`function`关键字在声明中（不只是一行代码，而应该是整个声明）的位置。如果`function`关键字在声明的最开始，则这是个函数声明；否则就是个函数表达式。

我们注意到函数声明和函数表达式的关键区别在于其命名作为一个标识符被绑定在何处。

比较上面两段代码。在第一段代码中，名称`foo`被绑定在所在作用域中，在这个作用域中可以直接通过`foo()`调用这个方法。在第二段代码中，名称`foo`被绑定在自身函数内部而不是其所在作用域。

换句话说，表达式`(function foo(){...})`意味着`foo`这个标识符只存在于`...`表示的区域内，而不在外部作用域中。将命名`foo`保存在自身作用域内部可以防止污染外部作用域。

#### 匿名和具名

你可能对于将函数表达式作为回调参数比较熟悉，比如：

```javascript
setTimeout(function (){
  console.log('I waited 1 second!');
}, 1000)
```

这叫“匿名函数表达式”，因为`function()...`没有名字。函数表达式可以是匿名的，但函数声明却不能----这是JS语法规定的。

匿名函数表达式创建起来简单方便，许多库和工具都推荐这种编码方式。但这种方式有几个缺点需要考虑：

1. 匿名函数在运行堆栈中没有名称显示，这会对代码调试造成一定的困难
2. 如果函数需要引用自己，比如递归等，在没有名字的情况下，只能使用已经被**弃用**的`arguments.callee`。另一个需要自引用的例子是事件触发函数在事件触发后想要解绑自己。
3. 函数的名称能使代码可读性更高，更容易理解。一个描述性的名字可以看成是一个自我描述的文档。

**行内函数表达式**非常强大和有用----匿名和具名的问题不会诋毁这一点。给函数表达式提供一个名字能有效的规避上面的缺点，而且还不会引起其他可察觉的错误。始终给你的函数表达式一个名字是最佳实践：

```javascript
setTimeout(function timeoutHandler(){ <---- Look, I have a name!
  console.log('I waited 1 second!');
}, 1000)
```

#### 立即触发函数表达式

```javascript
var a = 2;
(function foo(){
  var a = 3;
  console.log(a); // 3
})();
console.log(a); // 2
```

上面的代码中，通过将函数包裹在一对括号中我们有了一个函数表达式，我们可以通过在末尾再增加一个括号的方法来运行这个函数，比如`(function foo(){...})()`。第一对括号让这个函数变成了一个函数表达式，第二对括号则执行了这个函数。

这种模式很常见，几年前社区就给它起了个名字：**IIFE**，代表立即执行函数（**I**mmediately **I**nvoked **F**unction **E**xpression）。

当然，名字对IIFE来说并不是必要的----IIFE最常见的就是使用匿名函数表达式。然而，具名的函数表达式具有上面提到的匿名函数表达式的所有好处，所以在使用IIFE时最好使用具名函数表达式。

```javascript
var a = 2;
(function IIFE(){
  var a = 3;
  console.log(a); // 3
})();
console.log(a); // 2
```

相比传统的IIFE的形式，一些人喜欢这样：`(function(){...}())`。仔细观察这两者的差别。在上面的模式中，函数表达式被包裹在括号`()`中，然后触发函数的括号`()`处在前面那个括号的后面。第二种模式中，触发函数的括号`()`被放到了前面括号的里面。

这两种模式功能上都一样，完全取决于你更喜欢用哪个。

IIFE说白了还是一个函数调用，所以IIFE的另一个常见的用法是带参执行。

比如：

```javascript
var a = 2;
(function IIFE(global){
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
})(window);

console.log(a); // 2
```

我们传入了一个`window`对象的引用进去，但参数名称是`global，`这样我们对全局和非全局引用就有了一个简洁的文体上的区分。当然，你可以从所处作用域中传入你想传的任何东西，也可以给参数命名其他你觉得合适的名字。这些都是文体上的选择。

上面这种模式有个用处就是可以避免因 `undefined` 的值被错误的覆盖而引起的问题。通过将某一个参数命名为`undefined`，但不给这个参数传入任何值，就可以保证在这段方法中`undefined`的值是正确的。

```javascript
undefined = true; // setting a land-mine for other code! avoid!
(function IIFE(undefined){
  var a ;
  if(a === undefined){
    console.log('Undefined is safe here!');
  }
})();
```

IIFE的另一个变种是改变了一些代码执行的顺序：要执行的函数在触发和传参之后给出。这种模式被用在了UMD（Universal Module Definition）项目中。虽然啰嗦一些，但是一些人觉得还是比较容易理解的。

```javascript
var a = 2;
(function IIFE(def){
  def(window);
})(function def(gloabl){
    var a = 3;
    console.log(2); // 3;
    console.log(global.a); // 2
})
```

`def`这个函数表达式定义在上面代码的后半部分，并且作为参数传入到上半部分定义的`IIFE`函数的内部。最终，`window`作为`global`对应的实参传入到参数`def`（方法）中，然后`def`被执行。















