## 你不知道的JS：作用域和闭包

## 闭包

在讲述本章之前，希望你已经对作用域的工作方式有了深刻的理解。

现在我们将注意力转移到最重要的，也最难理解的部分：闭包。如果你一直紧跟着我们对词法作用域的讨论，那你会觉得闭包是很容易理解的。下面我们就来讲解闭包。

如果你对词法作用域还有些问题，那最好先去复习下第二章然后再回来。

### 启示

对于那些有很多经验，但依然没有掌握闭包的核心概念的人来说，理解闭包似乎需要很大的牺牲和付出。

回想几年前，我对JavaScript已经有了比较牢固的掌握，但对闭包依然不了解。我总感觉这门语言有个隐藏的东西，它比我之前遇到的都厉害，而我也深受其折磨。我记得我第一次阅读框架源码试图理解闭包工作方式的时候，我也记得“模块模式”第一次进入到我脑子里的时候，我也记得恍然大悟的那一刻。

那些我当时不知道的，一直期望理解的，以及我现在想要讲述给你听的，就是：**闭包在JavaScript中无处不在，你要学会识别和使用它**。闭包不是你需要学习新语法或者模式才能理解的东西，它甚至不需要你必须接受像Luke在原力中那样的修炼才能学会和掌握的武器。

闭包是词法作用域的一个产物，你不用去专门的创建闭包然后使用，它们就在那。你的代码中其实到处都有闭包，只不过你没有意识到它们的存在，也没有领略到它们的核心概念。

当你意识到闭包充满着你的代码并且你能看到它们时，就是你彻悟的时刻。理解闭包就像Neo第一次见到Matrix是那样。

### 事实真相

先给闭包下一个简单的定义：

> 函数在其词法作用域外执行时依然可以记住并获取到它词法作用域内部的东西，这就是闭包。

来看些代码：

```javascript
function foo(){
  var a = 2;
  function bar(){
    console.log(a);
  }
  bar();
}
foo();
```

这段代码和之前讨论嵌套作用域的代码很像。根据作用域的查询规则，函数`bar()`在作用域中可以访问到变量`a`（一个右查询引用）。

那么，这是一个闭包么？

嗯……从技术上来说，可能是吧。但根据我们上面的定义，又不是。我觉得更精确的描述是，`bar`能访问到`a`是通过作用域的查询规则完成的，而这些规则只是闭包的一个重要**组成部分之一**。

从学术角度来看，在上面代码中，函数`bar`拥有一个包含`foo()`作用域（当然还包括剩下的作用域，比如全局作用域）在内的闭包。稍微换个说法就是，`bar()`被封闭在了`foo()`作用域之内。为什么？因为`bar()`嵌套在`foo()`内部。

这种方式定义的闭包并不容易察觉，也不容易看出代码中闭包的运行。我们只看到了词法作用域，而闭包仍然处在代码的后面，保持着它的神秘面孔。

来看个把闭包带到聚光灯下的代码：

```javascript
function foo(){
  var a = 2;
  function bar(){
    console.log(2);
  }
  return bar;
}
var baz = foo();
baz(); // 2 -- Whoa, closure was just observed, man.
```

函数`bar`的词法作用域拥有着`foo()`内部作用域的访问权限。在这个例子中，我们把`bar()`当作值来传递----将`bar`指向的函数对象`return`了出来。

我们将`foo()`运行后的返回值（其内部的`bar()`函数）赋值给了变量`baz`，然后调用了`baz()`，其实这样相当于调用了内部的`bar()`函数，只是调用的标识符不一样而已。

`bar()`是执行了，而且还是在它被声明的词法作用域外执行的。

我们知道引擎会雇佣垃圾回收器来释放无用变量占用的内存，所以当`foo()`执行完毕后，我们倾向于认为它的内部作用域会消失----因为`foo()`内部的东西看起来已经没啥用了，所以这些内容会被回收。

但闭包的“魔法”不会让这些发生。`foo()`的内部作用域依然处于“使用中”，所以不会被回收。那谁在使用呢？**bar()函数**。

凭借自身声明的位置，`bar()`函数拥有一个包含`foo()`作用域在内的词法作用域闭包，这个闭包保存着对`foo()`作用域的引用，而`bar()`可以随时访问这个引用。

**`bar()`方法依然持有`foo()`作用域的引用，而这个引用叫做闭包**。

所以，在几微秒之后，当`baz()`（就是一开始在函数内部声明的`bar`）被调用时，它自然就拥有访问自身被定义时词法作用域的权限，所以也就可以访问到变量`a`。

函数在被定义时所处的词法作用域外调用，而**闭包**则允许函数可以继续访问它们被定义时所处的词法作用域。

当然，还有许多函数被传递其他地方被调用的例子，在这些例子中都可以观察到闭包。

```javascript
function foo(){
  var a = 2;
  function baz(){
    console.log(a); // 2
  }
  bar(baz);
}
function bar(fn){
  fn(); // look ma, I saw closure!
}
```

我们将内部函数`baz()`传递给了`bar()`，并在`bar()`内部调用了它（在内部是`fn`）。当我们这样做时，它对`foo()`内部作用域的闭包可以通过对变量`a`的访问观察到。

这种函数传递也可以是间接的，比如：

```javascript
var fn;
function foo(){
  var a = 2;
  function baz(){
    console.log(a);
  }
  fn = baz; // assign `baz` to global varible
}
function bar(){
  fn(); // look ma, I saw closure!
}
foo();
bar(); // 2
```

无论传递函数到它词法作用域外部的途径是啥，这个函数都会保留对其声明时所处词法作用域的访问，当我们在执行这个函数时，就会用到闭包。













