## 你不知道的JS：作用域和闭包

## 提升

到目前为止，你应该对作用域有了一定的了解，知道变量是如何根据它们声明的位置来绑定到不同层级的作用域的。函数作用域和块级作用域都遵循着同样的规则：变量在哪个作用域声明的，它就属于哪个作用域。

但这里有个细节：在作用域的多处位置都有声明的变量绑定到作用域的行为是怎样的？接下来，我们就来讨论这个细节。

### 先有鸡还是先有蛋

经常有人认为，JavaScript中的代码是从上到下一行行执行的。这种看法只能说大体上是对的，而且这种看法会让对代码产生错误的理解：

```javascript
a = 2;
var a;
console.log(a);
```

你觉得`console.log(...)`的打印结果是什么？

许多开发者会认为结果是`undefined`，因为`var a `语句在`a = 2`后面，很自然的能想到变量被重定义了，所以变量被赋值为默认值`undefined`。但实际结果是`2`。

在看下面的代码：

```javascript
console.log(a);
var a = 2;
```

你可能觉得，之前一段代码看起来似乎有些没有按照从上到下的顺序执行，所以这段代码可能会输出`2`。也有人觉得变量`a`在声明前就使用了，所以会有一个`ReferenceError`错误抛出。

但不幸的是，这两种答案都是错的。输出结果是`undefined`。

**所以，这到底是怎么回事？**好像我们陷入了先有鸡还是先有蛋的问题，是声明在先（鸡蛋），还是赋值在先（鸡）？

### 编译器理论

回想一下第一章关于编译器的讨论。我们知道，代码执行前引擎会先对其进行编译。编译过程中会找到所有声明并将这些声明绑定到各自的作用域中。这一过程构成了第二章词法作用域的核心。

所以，总结下就是所有的变量声明和函数声明在代码执行前会被预先处理掉。

对于代码`var a = 2;`，大多数人会认为这只是一个语句。但引擎实际将其认为成是两段语句：`var a;`和`a = 2;`。第一个语句中的声明操作会在编译阶段完成；第二个语句中的赋值操则会待在它本来的地方等待执行阶段的执行。

所以，一开头第一个例子中代码的处理过程大致如下：

```javascript
var a;
```

```javascript
a = 2;
console.log(a);
```

第一段代码在编译阶段执行，而第二段则是在执行阶段执行。

同样的，第二个例子中代码的处理过程大致如下：

```javascript
var a;
```

```javascript
console.log(a);
a = 2;
```

可以这样来理解这个过程：变量声明和函数声明会从它们本来的位置移动到它们所在代码块的头部。我们把这个过程叫做“提升”。

也就是说，**先有鸡（声明），后有蛋（赋值）**。

**注意**：只有声明是会提升的，对于赋值及其他代码逻辑依然会在原地等待执行。因为如果提升会重置我们代码的执行逻辑的话，这会导致严重的后果。

```javascript
foo();
function foo(){
  console.log(a);
  var a = 2;
}
```

对函数`foo`的声明（这里还包括将其赋值为一个函数）会被提升，这样才能在第一行去调用执行它。

另外还需要注意的是，**提升是以作用域为单位的**。一开始的例子因为是处于全局作用域中，所以直接拆成了两部分。而在我们正在测试的`foo()`函数中，可以看到`var a `只是被提升到了`foo()`作用域的顶部。所以上面的例子可以更精确的改写成下面这样：

```javascript
function foo(){
  var a;
  console.log(a); // undefined
  a = 2;
}
foo();
```

函数声明会被提升，这个我们已经看到了。但是函数表达式却不会。

```javascript
foo(); // not ReferenceError, but TypeError!
var foo = function bar(){
	// ...
}
```

变量`foo`会提升到所在作用域顶部（就是全局作用域），所以`foo()`并不会引起一个`ReferenceError`。虽然提到了顶部，但是此时`foo`并没有值（如果是个函数声明的话此时会有值）。所以，`foo()`其实是把`undefined`当成函数来运行了，最终造成了一个`TypeError`错误。

如果函数表达式有名字，那这个名字在当前作用域中也是不可用的：

```javascript
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar(){
  // ..
}
```

存在提升的情况下，上面的代码可以转换如下：

```javascript
var foo;
foo(); // TypeError
bar(); // ReferenceError
foo = function(){
  var bar = ..self..
  //..
}
```

