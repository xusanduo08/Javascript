## 你不知道的JS：`this`和对象原型

## 第二章：`this`深入理解

在第一章，我们介绍了几种对`this`的错误理解，知道了`this`是在函数调用时发生的完全取决于调用位置的绑定。

### 调用位置

在理解`this`之前，我们必须理解函数的调用位置：函数的调用位置就是代码中函数被触发执行的位置（**不是声明位置**）。我们必须深入到调用位置中，才能回答问题：`this`到底指向的是什么？

一般来说查找调用位置就是：“找到函数被触发调用的位置”，但也并不是一直这样，有一些特定的编码模式会让真正的调用位置变得隐晦。

重点要关注的是**调用堆栈**（到达当前执行位置所调用的函数组成的堆栈），我们关心的调用位置就在当前执行函数的前一个函数调用中。

下面来展示下调用堆栈和调用位置：

```javascript
function baz(){
  // call-stack is: `baz`
  // so, our call-site is in the global scope
  
  console.log('baz');
  bar(); // <-- call-site for `bar`
}
function bar(){
  // call-stack is: `baz` -> `bar`
  // so, our call-site is in `baz`
  console.log('bar');
  foo(); // <-- call-site for `foo`
}
function foo(){
  // call-stack is: `baz` -> `bar` -> `foo`
  // so, our call-site is in `bar`
  
  console.log('foo');
}

baz(); // <-- call-site for `baz`
```

着重我们是如何从调用堆栈中找到调用位置的，因为这是唯一影响`this`的绑定的因素。

**注意：**你可以根据函数的调用链在头脑中构建调用堆栈，就像上面代码中的注释那样。但这个过程比较痛苦且易出错。另一个查看调用堆栈的方法是使用浏览器中的调试工具。大多数现代浏览器都内置了包含JS引擎在内的调试工具。上面代码中，你可以使用工具在`foo()`方法的第一行设置一个断点，或者直接在第一行插入`debugger`语句。在运行时，调试器就会在这个位置停下来，并且会展示一个由为了到达当前位置所调用的函数组成的列表，这个列表就是调用堆栈。所以，你可以通过开发工具获取到调用堆栈，然后从上至下找到栈中的第二个元素，这个位置就是目标函数的调用位置。

### 规则

现在让我们把注意力转移到调用位置是如何影响`this`指向的。

首先你需要找到调用位置，然后判断适用下面4条规则的哪一条。我们会对`this`绑定的4条规则分别做解释，然后讲解在适用多个规则时这些规则的优先权。

#### 默认绑定

第一条规则来源于最常见的函数调用方式：独立函数调用。当没有其他规则适用时，这条规则可以认为是默认规则。

考虑下面的代码：

```javascript
function foo(){
  console.log(this.a);
}
var a = 2;
foo(); // 2
```

首先要知道一点，在全局作用域中声明的变量，比如`var a = 2`，其实就是全局对象的同名属性，它们本质上就是同一个东西，而不是复制得来的。就像一个硬币的正反面一样。

第二，我们看到`foo()`在调用后，`this.a`最终指向的是全局变量`a`，为什么？因为在这个例子中，`this`的默认绑定规则适用于当前情况，所以`this`指向的是全局对象。

我们是如何知道默认规则适用于当前这个例子的？先通过调用位置看下`foo()`是如何被调用的。在代码中，`foo()`是通过没加任何修饰的函数引用直接调用的。其他规则在这都不适用，所以，只能适用默认规则。

在严格模式中，默认绑定规则会失效，因此`this`值此时是`undefined`：

```javascript
function foo(){
  'use strict';
  console.log(this.a);
}
var a = 2;
foo(); // TypeError: `this` is `undefined`
```

一个非常重要的细节是：虽然`this`的绑定规则完全取决于调用位置，但只有在非严格模式下，默认绑定才能绑定到全局对象上；严格模式下`foo()`的调用位置不会影响`this`的绑定。

```javascript
function foo(){
  console.log(this.a);
}
var a = 2;
(function(){
  'use strict';
  foo(); //2
})();
```

**注意：**不要在代码中混用严格模式和非严格模式，你的代码应该要么是严格模式的要么是非严格模式的。有时候引用的一些第三方代码库会使用和你的代码不一样的模式，所以对于上面提到的细节要有所了解和关注。















