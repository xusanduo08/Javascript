## 你不知道的JS：`this`和对象原型

## 第二章：`this`深入理解

在第一章，我们介绍了几种对`this`的错误理解，知道了`this`是在函数调用时发生的完全取决于调用位置的绑定。

### 调用位置

在理解`this`之前，我们必须理解函数的调用位置：函数的调用位置就是代码中函数被触发执行的位置（**不是声明位置**）。我们必须深入到调用位置中，才能回答问题：`this`到底指向的是什么？

一般来说查找调用位置就是：“找到函数被触发调用的位置”，但也并不是一直这样，有一些特定的编码模式会让真正的调用位置变得隐晦。

重点要考虑**调用堆栈**（到达当前执行位置所调用的函数堆栈）。我们关心的调用位置就在当前执行函数的前一个函数调用中。

我们来展示下调用堆栈和调用位置：

```javascript
function baz(){
  // call-stack is: `baz`
  // so, our call-site is in the global scope
  
  console.log('baz');
  bar(); // <-- call-site for `bar`
}
function bar(){
  // call-stack is: `baz` -> `bar`
  // so, our call-site is in `baz`
  console.log('bar');
  foo(); // <-- call-site for `foo`
}
function foo(){
  // call-stack is: `baz` -> `bar` -> `foo`
  // so, our call-site is in `bar`
  
  console.log('foo');
}

baz(); // <-- call-site for `baz`
```

重点关注我们是如何从调用堆栈中找到调用位置的，因为这是唯一影响`this`的绑定的因素。

**注意：**你可以根据函数的调用链在头脑中构建调用堆栈，就像上面代码中的注释那样。但这个过程比较痛苦且易出错。另一个查看调用对战的方法是使用浏览器中的调试工具。大多数现代浏览器都内置了包含JS引擎在内的调试工具。上面代码中，你可以使用工具在`foo()`方法的第一行设置一个断点，或者直接在第一行插入`debugger`语句。在运行时，调试器就会在这个位置停下来，并且会展示一个由为了到达当前位置所调用的函数组成的列表，这个列表就是调用堆栈。所以，你可以通过开发工具获取到调用堆栈，然后从上至下找到栈中的第二个元素，这个位置就是目标函数的调用位置。

