## 你不知道的JS：作用域和闭包

## 提升

到目前为止，你应该对作用域有了一定的了解，知道变量是如何根据它们声明的位置来绑定到不同层级的作用域的。函数作用域和块级作用域都遵循着同样的规则：变量在哪个作用域声明的，它就属于哪个作用域。

但这里有个细节：在作用域的多处位置都有声明的变量绑定到作用域的行为是怎样的？接下来，我们就来讨论这个细节。

### 先有鸡还是先有蛋

经常有人认为，JavaScript中的代码是从上到下一行行执行的。这种看法只能说大体上是对的，而且这种看法会让对代码产生错误的理解：

```javascript
a = 2;
var a;
console.log(a);
```

你觉得`console.log(...)`的打印结果是什么？

许多开发者会认为结果是`undefined`，因为`var a `语句在`a = 2`后面，很自然的能想到变量被重定义了，所以变量被赋值为默认值`undefined`。但实际结果是`2`。

在看下面的代码：

```javascript
console.log(a);
var a = 2;
```

你可能觉得，之前一段代码看起来似乎有些没有按照从上到下的顺序执行，所以这段代码可能会输出`2`。也有人觉得变量`a`在声明前就使用了，所以会有一个`ReferenceError`错误抛出。

但不幸的是，这两种答案都是错的。输出结果是`undefined`。

**所以，这到底是怎么回事？**好像我们陷入了先有鸡还是先有蛋的问题，是声明在先（鸡蛋），还是赋值在先（鸡）？

### 编译器理论

回想一下第一章关于编译器的讨论。我们知道，代码执行前引擎会先对其进行编译。编译过程中会找到所有声明并将这些声明绑定到各自的作用域中。这一过程构成了第二章词法作用域的核心。

所以，总结下就是所有的变量声明和函数声明在代码执行前会被预先处理掉。

对于代码`var a = 2;`，大多数人会认为这只是一个语句。但引擎实际将其认为成是两段语句：`var a;`和`a = 2;`。第一个语句中的声明操作会在编译阶段完成；第二个语句中的赋值操则会待在它本来的地方等待执行阶段的执行。

所以，一开头第一个例子中代码的处理过程大致如下：

```javascript
var a;
```

```javascript
a = 2;
console.log(a);
```

第一段代码在编译阶段执行，而第二段则是在执行阶段执行。

同样的，第二个例子中代码的处理过程大致如下：

```javascript
var a;
```

```javascript
console.log(a);
a = 2;
```

可以这样来理解这个过程：变量声明和函数声明会从它们本来的位置移动到它们所在代码块的头部。我们把这个过程叫做“提升”。

也就是说，**先有鸡（声明），后有蛋（赋值）**。

**注意**：只有声明是会提升的，对于赋值及其他代码逻辑依然会在原地等待执行。因为如果提升会重置我们代码的执行逻辑的话，这会导致严重的后果。

```javascript
foo();
function foo(){
  console.log(a);
  var a = 2;
}
```

对函数`foo`的声明（这里还包括将其赋值为一个函数）会被提升，这样才能在第一行去调用执行它。

另外还需要注意的是，**提升是以作用域为单位的**。一开始的例子因为是处于全局作用域中，所以直接拆成了两部分。而在我们正在测试的`foo()`函数中，可以看到`var a `只是被提升到了`foo()`作用域的顶部。所以上面的例子可以更精确的改写成下面这样：

```javascript
function foo(){
  var a;
  console.log(a); // undefined
  a = 2;
}
foo();
```

函数声明会被提升，这个我们已经看到了。但是函数表达式却不会。

```javascript
foo(); // not ReferenceError, but TypeError!
var foo = function bar(){
	// ...
}
```

变量`foo`会提升到所在作用域顶部（就是全局作用域），所以`foo()`并不会引起一个`ReferenceError`。虽然提到了顶部，但是此时`foo`并没有值（如果是个函数声明的话此时会有值）。所以，`foo()`其实是把`undefined`当成函数来运行了，最终造成了一个`TypeError`错误。

如果函数表达式有名字，那这个名字在当前作用域中也是不可用的：

```javascript
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar(){
  // ..
}
```

存在提升的情况下，上面的代码可以转换如下：

```javascript
var foo;
foo(); // TypeError
bar(); // ReferenceError
foo = function(){
  var bar = ..self..
  //..
}
```

### 函数优先

函数声明和变量声明都会提升，但两者还是有差别（当代码中有多个重复声明时会体现出来）的：函数声明会先被提升，然后才是变量声明。

看下面的代码：

```javascript
foo(); // 1
var foo;
function foo(){
  console.log(1);
}
foo = function(){
  console.log(2);
}
```

上面代码最终输出`1`而不是`2`。引擎会将上面代码解释成下面的样子然后执行：

```javascript
function foo(){
  console.log(1);
}
foo(); // 1
foo = function(){
  console.log(2);
}
```

因为函数声明会先于正常的变量声明做提升，所以尽管`var foo`在代码中出现在`function foo()...`的前面，也会因为是一个重复的声明而被忽略。

虽然重复的`var`声明会被忽略，但后面的函数声明确实会覆盖前面的声明：

```javascript
foo(); // 3
function foo(){
  console.log(1);
}
var foo = function(){
  console.log(2);
}
function foo(){
  console.log(3);
}
```

虽然这些东西听起来像是一些无趣的琐事，但强调了一个事实：在同一个作用域中做重复定义不是一个好主意，而且还经常引起一些令人迷惑的结果。

在正常代码块中做的函数声明会提升到当前作用域顶部，不会受到条件语句的影响，比如：

```javascript
foo(); // 'b'
var a = true;
if(a){
  function foo(){console.log('a');}
} else {
  function foo(){console.log('b');}
}
```

但有一点要注意，上面的这种行为不可靠，在JavaScript未来的版本中对此可能有所更改，所以最好不要在代码块内部声明函数。

### 小结

我们更多的会将`var a = 2`看成是一个语句，但引擎却不会。引擎会将其分成两个语句：`var a;`和`a = 2;`，第一个语句在编译阶段执行，而第二个语句则在执行阶段执行。

这会导致所有的声明都会先于代码本身执行，无论这些声明出现在何处。你可以理解为声明操作（变量声明和函数声明）被移动到了它们所处作用域的顶部。我们将这种行为叫做“提升”。

声明是被提升了，但是赋值操作还是待在原地，包括使用函数表达式的赋值。

要小心应对重复声明，尤其是`var`声明和函数声明混合时，要格外注意。

