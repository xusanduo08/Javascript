Hello everyone, welcome to React Conf. I'm really excited to be here. I'm really excited for the stuff that we have to announce for you this week.My name is Sophie Alpert on the Internet. I manage the React core team at Facebook by any manager that you use.React is doing great our NPM downloads are up 70% year-over-year, the chrome dev tools extension for React dev tools has been installed by one and a quarter million developers and I can show you this list of companies that's using React although at this point it's so long,it's kind of hard to tell how much it changes each year.For another point of data we can look at Google Trends which shows web search traffic,so it searches for React continue to go up, hopefully that means more people are using React, not that it's getting more confusing.But for a point of  comparison we can look at a trade jquery which we have just passed for the first time in history. But this also shows that we have a lot more room to grow. I was procrastinating when I was writing this talk so I was curious to see what else React is more popular than whoops spoiled my joke. But React is more popular I found out than renewable energy,it's also more popular than orange juice, just think about how common orange juice is right.And not only that it's more popular than renewable energy and orange juice puttogether,so I think we have a lot to be proud of .But ,enough about these numbers, what I really like to talk about today is our mission with React.Ever since React was released in 2013, our overarching goal, our primary mission has been to make it easier to build great UIs and so when we're adding new features we always try to be very deliberate, we want to consider a bunch of things when deciding whether to add a new API, if it makes it possible to do something you couldn't do before,if it can dramatically simplify the code around React in your components and libraries so that you all have less work to do and users have less code to download ,that's a win. Or if it hepls encourage best practices,  like code splitting, if we make it easier to code split your app into multiple bundles then our hope is that your apps will end up being faster so that's why we add things like  React dot lazy which we announced two days ago.You might have seen it .But thinking about this mission, make it easier to build great UIs,there are a lot of different ways that we approach this, one way we do this is tring to smplify things that are hard.If you saw Dayton Dan Abramov stalk from JS conf Iceland then you saw a sneak peek at suspense which is our idea about how to dramatically simplify what's required to do data fetching, code splitting and any kind of async data dependencies in your app.

Now another way to improve React is by focusing on performance.If you app run faster your users are going to enjoy using it more. Conversely, if your app is laggy, if your app is janky then your users aren't gonna have a great time, so we try to spend time on making React so faster.Because if React is faster out of the box you all need to spend less time optimizing your own code.One recent performance related effort  that Dan also talked about in Iceland as what we call time slicing,this is going to let you make sure that the most important renders in your app are processed first, in order to unblock the main thread and make your apps faster.And a third angle that we approach our mission from is developer tooling to help you debug and understand your app.From the start, React has included developer friendly warnings to help point out problems before you might otherwise notice them and we've had the Reactive tools extension whick lets you inspect and debug your components trees.And inn React 16-5 we introduce a new profiler, it's a second. I don't know what's up with this clicker a second tab. A second tab there, profiler tab, that helps you understand what's happening in your app and optimize it. So, Suspense, Time Slicing and the Profiler are three of the new features that we've been working on over the last year.We're really excited to tell you more about them.But that's actually not what I'm here to talk about.You're gonna have to wait till Andrew and Brian's talk tomorrow morning to hear about that. Today I want to take a step back and focus on something else. What I like to ask is what in React still sucks. And I have three problems that I would like to talk through.

The first one is reusing logic between multiple components. In React our main building block for our applications is a component, and components form the foundation of the two main patterns for sharing code in React apps between components which are Higher-order components and Render props. Both of these parrerns are great for some cases, but they also come with a significant downside. You need to restructure your app anytime you want to pull one of  these in more complicated examples. This leads to what I call wrapper hell, most of us have seen components trees that look something like this. And the nesting you end up with  maks it difficult to follow the data flow through the app. It would be really nice if there was some way to reuse this sort of stateful logic without needing to change the component hierarchy, right. 

The second problem I would like to talk about is giant components whose logic is just sort of a tangled mess. When you look at a thousand line React component chances are the logic is going to be split across a lot of different lifecycle methods in a way that's pretty difficult to follow. Let's look at an example. Let's say we have a class component, and in its component did mount method it does a few different things: it subscribes to a database, it sends off a network requests and it starts a timer. Well, if we look at the component will unmount method, then we're going to see basically exact three opposite things: it needs to unsubscribe from the store, it needs to cancel that network request and it needs to stop the timers. And when it comes to implementing component did update, the logic tends to get even tricker because you need to compare the old and new props and also mirror it again the same tasks that you have in your other lifecycle methods.Uh, in this example, each call here is just one line so this is actually a lot simpler than what you normally see in your components. In real-world components you often end up with an even more tangled mess, because each individual task has to be split across different lifecycle methods, that makes it hard to tell if , for instance, you forgot to clean up one of the resources when you're unmounting your component. It's pretty hard to see that from the code.

And the third thing that sucks is the class, understanding classes in Javascript can be pretty tricky, and today we require you to use class components in order to access state and lifecycles. If you've even taken a function component and converted it to a class to add some state, you know that there's a fair amount of boilerplate that's required in order to just define a class component. Most beginners and many experienced devs also tell us that the way binding and this work in classes is pretty confusing. It's annoying to think about it .And we also frequently hear that people don't exactly know when to use function components partly because there's always this fear that you're gonna have to convert it to a class later anyway. And so you're like should I, should I do it now? I don't know. And so I claim classes are hard for humans, uh, but it's not just humans, I claim the classes are also hard for machines. If you ever looked at a minified component file, you'll see that all the method names are still unminified. And that if you have a method that's completely unused, it doesn't get stripped out. That's because it's hard to tell at compile time exactly how all the methods fit together. We also found that classes make it difficult for us to implement hot reloading reliably. And finally when we were prototyping an optimizing compiler to improve the performance of React components, we found that classes can encourage some patterns that make it a lot harder for compilers to optimize. So here are the three problems that we have:reusing logic, giant components, and classes. So reusing logic because you often end up with this wrapper hell.Giant components because you have the logic split across different lifecyles. And classes which are difficult for both humans and machines. So we think we have a solution that can help with all three of these. We're really excited to share it with you to tell you more about it . I want to welcome up Dan Abramov.



My name is Dan, I  work on the React team and this is my first time in React conf. And so if we talked about these problems that I think most of you have encountered in React development and of  course we could approach these problems one by one so we could try to solve them in isolation, but it seem like solving one of them makes some other one worse, so for example if we try to solve the rapper hell by putting more logic into components themselves then our components become larger and harder to refactor and then on the other hand if we try to split the components apart into smaller pieces and reuse those then we end up with more nests that in the component tree and we get the rapper hell again. And finally in either case we have all the confusion that comes with classes so we think that this is because these are not three separate, we think that these are three symptoms of one problem and the problem is that React does not provide a simpler smaller lightweight primitive to add state of lifecycle than a class component and so once you add a class component you can split up further without introducing the rapper hell. And in fact it's not a new problem so if you used to React for like more than a couple of years you might remember them when React came out it actually included a solution to this problem, it was mixins, so mixins allows you to reuse some methods between classes and this way you wouldn't have all these rappers so should we add mixins back to React? That's right , no, no we're not gonna do that. I mean the codes use mixins the rounds it's not like, it's not broken, but we don't encourage using mixins in React. If you curious why there is a blog post that we wrote code called mixins considered harmful on the React blog where we explain that we think in our experience, the problems that mixins create are worse than the problems that they solve, so that's why we don't encourage these mixins. So perhaps we could just can't solve this problem , maybe it's inherent to the React component model, maybe we should just accept it or maybe in a perhaps there is a different way we could write our components that doesn't suffer from either of these problems and that's what I'm going to talk about today. But before I start , I want to touch a little bit on the way we approach making changes and additions to React which is  a year ago we set up an RFC process, so RFC stands for request for comments and it means that whenever we want to make or somebody else wants to make a substantial change or addition to React, they need to write up a proposal with detailing the motivation and the detail design of how this will work. So that's what we're going to do. We're excited to announce that we are ready to proposal for how we can solve these three problems and importantly this proposal does not have breaking changes or deprecations in it.It is strictly additive, it is opt-in and it adds some new apis which happens when you try to solve these problems and we would love to hear your feedback on this proposal which is we're going to publish it today. And we thought about many ways we could share this proposal so maybe we just like right off in there write up an RFC and post it but since we were going to run React conf andway we just decided to show it here and we're gonna do a demo with the mirrors.



Alright , so here is a simple React component that just it is a row, this is just some styling and it renders a person's name and so let's say that we want this name to be editable so how do you do it in React normally well like. If we want to add an input there we need to return this component into a class add some local state to it and let that state drive the input so that's exactly what I'm going to do, that's what we do today, so I'm going to do the expert default class greeting extends React component and so I'm going to use  only stable JavaScript syntax so constructor props, super props, there is the state going to initialize name to Mary here and I'm going to declare a  render method and copy and paste this. So I want to be instead of just rendering the name, I want the surrender and input, so I'm replacing this by an input and the value of the input is this that state that name and if I make a change I want to call this dot handle name change, that's going to be my change color and I'm going to declare it here when the name changes we call this .setState like we normally do and we set the name to e at target dot value. Right. So now, if edit, so I need to bind, sorry, I need to bind the eventhandlers, so now I can actually edit it and it works a familiar class component. If you work with React you probably write a lot of  those but let's take a step back what if we didn't have to write a class when we want use state? So I'm not sure how that's gonna work but I'll just start with what I know, I want to render an input, so I'm gonna put an input here and the input has a value and that value is the current name, so I'll just pass name. I don't know where to get name from , so it doesn't come from props. I'll just declare it and I don't know, I'll fit it in later, this is gonna have a change down there as well , so I'm going do declare unchanged handle name change and I'm adding a function here takes an event and then here I want tell React to set the name to something, but again I'm not sure how to do that from a functional component so I'll just call something called setName with current input value, and I'll just upload it here. All right, so these two things, they're closely related, right, so one of them is the current value of the name state variable and the other is a function that lets us set the name state variable. And so because these things are closely related I'm going to put them together as a pair of values, so I'm going to get them from somewhere, so where do I get them from , from local state, so how do I use React local state from a function component, well what if I could just use state and past the initial state to specify it, and see if this works, yeah it works. So let's compare the two approaches, so on the left we have a familiar class component , this state has to be an object, we bind some event handlers so that we can access this inside the event handler, for this that's a state. When we call setState it actually doesn't just set the state that merges, the state are the argument into the state object and then when we want to access the state which it is that state and that's something. So in the example on the right we don't need to access this that stayed at something because the name state variable is already available in the function, it's just the variable and similarly when we need to set the state, we don't need to access this that's something, because the function that let's has said the name is also available in the scope, so what is use state exactly your state is a hook. A hook is a function provided by React that lets you hook into React features from your function components and you stated is the first hook that we're going to take a look at today but there are a few more so we're going to see them later.

All right , so let's go back to our familiar class example , so let's say we wanted to add a second field, for example , for a surname, so the way we normally do this is we add another key to the state and I'm going to copy and paste this role, it's gonna say surname now, it's going to render surname and handle surname change when I copy and paste this event handler, this will be surname and I need to bind it . So we can see that it works. So how do we do the same with hooks, so one thing we could do is we could make our state an object, as you can see that the state with hook state doesn't have to be an object, it can be any primitive, we could make it an object if we wanted to but we also don't have to. So conceptually surname is not closely related to state to the name , so what we could do is we could declare a second state variable by calling the you state hook again. So all declare surname I can give it any name, it's just the variable in my code and sets her name by calling you state and passing the initial state for that. 

24分10秒