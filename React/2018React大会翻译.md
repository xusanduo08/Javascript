Hello everyone, welcome to React Conf. I'm really excited to be here. I'm really excited for the stuff that we have to announce for you this week.My name is Sophie Alpert on the Internet. I manage the React core team at Facebook by any manager that you use.React is doing great our NPM downloads are up 70% year-over-year, the chrome dev tools extension for React dev tools has been installed by one and a quarter million developers and I can show you this list of companies that's using React although at this point it's so long,it's kind of hard to tell how much it changes each year.For another point of data we can look at Google Trends which shows web search traffic,so it searches for React continue to go up, hopefully that means more people are using React, not that it's getting more confusing.But for a point of  comparison we can look at a trade jquery which we have just passed for the first time in history. But this also shows that we have a lot more room to grow. I was procrastinating when I was writing this talk so I was curious to see what else React is more popular than whoops spoiled my joke. But React is more popular I found out than renewable energy,it's also more popular than orange juice, just think about how common orange juice is right.And not only that it's more popular than renewable energy and orange juice puttogether,so I think we have a lot to be proud of .But ,enough about these numbers, what I really like to talk about today is our mission with React.Ever since React was released in 2013, our overarching goal, our primary mission has been to make it easier to build great UIs and so when we're adding new features we always try to be very deliberate, we want to consider a bunch of things when deciding whether to add a new API, if it makes it possible to do something you couldn't do before,if it can dramatically simplify the code around React in your components and libraries so that you all have less work to do and users have less code to download ,that's a win. Or if it hepls encourage best practices,  like code splitting, if we make it easier to code split your app into multiple bundles then our hope is that your apps will end up being faster so that's why we add things like  React dot lazy which we announced two days ago.You might have seen it .But thinking about this mission, make it easier to build great UIs,there are a lot of different ways that we approach this, one way we do this is tring to smplify things that are hard.If you saw Dayton Dan Abramov stalk from JS conf Iceland then you saw a sneak peek at suspense which is our idea about how to dramatically simplify what's required to do data fetching, code splitting and any kind of async data dependencies in your app.

Now another way to improve React is by focusing on performance.If you app run faster your users are going to enjoy using it more. Conversely, if your app is laggy, if your app is janky then your users aren't gonna have a great time, so we try to spend time on making React so faster.Because if React is faster out of the box you all need to spend less time optimizing your own code.One recent performance related effort  that Dan also talked about in Iceland as what we call time slicing,this is going to let you make sure that the most important renders in your app are processed first, in order to unblock the main thread and make your apps faster.And a third angle that we approach our mission from is developer tooling to help you debug and understand your app.From the start, React has included developer friendly warnings to help point out problems before you might otherwise notice them and we've had the Reactive tools extension whick lets you inspect and debug your components trees.And inn React 16-5 we introduce a new profiler, it's a second. I don't know what's up with this clicker a second tab. A second tab there, profiler tab, that helps you understand what's happening in your app and optimize it. So, Suspense, Time Slicing and the Profiler are three of the new features that we've been working on over the last year.We're really excited to tell you more about them.But that's actually not what I'm here to talk about.You're gonna have to wait till Andrew and Brian's talk tomorrow morning to hear about that. Today I want to take a step back and focus on something else. What I like to ask is what in React still sucks. And I have three problems that I would like to talk through.

The first one is reusing logic between multiple components. In React our main building block for our applications is a component, and components form the foundation of the two main patterns for sharing code in React apps between components which are Higher-order components and Render props. Both of these parrerns are great for some cases, but they also come with a significant downside. You need to restructure your app anytime you want to pull one of  these in more complicated examples. This leads to what I call wrapper hell, most of us have seen components trees that look something like this. And the nesting you end up with  maks it difficult to follow the data flow through the app. It would be really nice if there was some way to reuse this sort of stateful logic without needing to change the component hierarchy, right. 

The second problem I would like to talk about is giant components whose logic is just sort of a tangled mess. When you look at a thousand line React component chances are the logic is going to be split across a lot of different lifecycle methods in a way that's pretty difficult to follow. Let's look at an example. Let's say we have a class component, and in its component did mount method it does a few different things: it subscribes to a database, it sends off a network requests and it starts a timer. Well, if we look at the component will unmount method, then we're going to see basically exact three opposite things: it needs to unsubscribe from the store, it needs to cancel that network request and it needs to stop the timers. And when it comes to implementing component did update, the logic tends to get even tricker because you need to compare the old and new props and also mirror it again the same tasks that you have in your other lifecycle methods.Uh, in this example, each call here is just one line so this is actually a lot simpler than what you normally see in your components. In real-world components you often end up with an even more tangled mess, because each individual task has to be split across different lifecycle methods, that makes it hard to tell if , for instance, you forgot to clean up one of the resources when you're unmounting your component. It's pretty hard to see that from the code.

And the third thing that sucks is the class, understanding classes in Javascript can be pretty tricky, and today we require you to use class components in order to access state and lifecycles. If you've even taken a function component and converted it to a class to add some state, you know that there's a fair amount of boilerplate that's required in order to just define a class component. Most beginners and many experienced devs also tell us that the way binding and this work in classes is pretty confusing. It's annoying to think about it .And we also frequently hear that people don't exactly know when to use function components partly because there's always this fear that you're gonna have to convert it to a class later anyway. And so you're like should I, should I do it now? I don't know. And so I claim classes are hard for humans, uh, but it's not just humans, I claim the classes are also hard for machines. If you ever looked at a minified component file, you'll see that all the method names are still unminified. And that if you have a method that's completely unused, it doesn't get stripped out. That's because it's hard to tell at compile time exactly how all the methods fit together. We also found that classes make it difficult for us to implement hot reloading reliably. And finally when we were prototyping an optimizing compiler to improve the performance of React components, we found that classes can encourage some patterns that make it a lot harder for compilers to optimize. So here are the three problems that we have:reusing logic, giant components, and classes. So reusing logic because you often end up with this wrapper hell.Giant components because you have the logic split across different lifecyles. And classes which are difficult for both humans and machines. So we think we have a solution that can help with all three of these. We're really excited to share it with you to tell you more about it . I want to welcome up Dan Abramov.



My name is Dan, I  work on the React team and this is my first time in React conf. And so if we talked about these problems that I think most of you have encountered in React development and of  course we could approach these problems one by one so we could try to solve them in isolation, but it seem like solving one of them makes some other one worse, so for example if we try to solve the rapper hell by putting more logic into components themselves then our components become larger and harder to refactor and then on the other hand if we try to split the components apart into smaller pieces and reuse those then we end up with more nests that in the component tree and we get the rapper hell again. And finally in either case we have all the confusion that comes with classes so we think that this is because these are not three separate, we think that these are three symptoms of one problem and the problem is that React does not provide a simpler smaller lightweight primitive to add state of lifecycle than a class component and so once you add a class component you can split up further without introducing the rapper hell. And in fact it's not a new problem so if you used to React for like more than a couple of years you might remember them when React came out it actually included a solution to this problem, it was mixins, so mixins allows you to reuse some methods between classes and this way you wouldn't have all these rappers so should we add mixins back to React? That's right , no, no we're not gonna do that. I mean the codes use mixins the rounds it's not like, it's not broken, but we don't encourage using mixins in React. If you curious why there is a blog post that we wrote code called mixins considered harmful on the React blog where we explain that we think in our experience, the problems that mixins create are worse than the problems that they solve, so that's why we don't encourage these mixins. So perhaps we could just can't solve this problem , maybe it's inherent to the React component model, maybe we should just accept it or maybe in a perhaps there is a different way we could write our components that doesn't suffer from either of these problems and that's what I'm going to talk about today. But before I start , I want to touch a little bit on the way we approach making changes and additions to React which is  a year ago we set up an RFC process, so RFC stands for request for comments and it means that whenever we want to make or somebody else wants to make a substantial change or addition to React, they need to write up a proposal with detailing the motivation and the detail design of how this will work. So that's what we're going to do. We're excited to announce that we are ready to proposal for how we can solve these three problems and importantly this proposal does not have breaking changes or deprecations in it.It is strictly additive, it is opt-in and it adds some new apis which happens when you try to solve these problems and we would love to hear your feedback on this proposal which is we're going to publish it today. And we thought about many ways we could share this proposal so maybe we just like right off in there write up an RFC and post it but since we were going to run React conf andway we just decided to show it here and we're gonna do a demo with the mirrors.



Alright , so here is a simple React component that just it is a row, this is just some styling and it renders a person's name and so let's say that we want this name to be editable so how do you do it in React normally well like. If we want to add an input there we need to return this component into a class add some local state to it and let that state drive the input so that's exactly what I'm going to do, that's what we do today, so I'm going to do the expert default class greeting extends React component and so I'm going to use  only stable JavaScript syntax so constructor props, super props, there is the state going to initialize name to Mary here and I'm going to declare a  render method and copy and paste this. So I want to be instead of just rendering the name, I want the surrender and input, so I'm replacing this by an input and the value of the input is this that state that name and if I make a change I want to call this dot handle name change, that's going to be my change color and I'm going to declare it here when the name changes we call this .setState like we normally do and we set the name to e at target dot value. Right. So now, if edit, so I need to bind, sorry, I need to bind the eventhandlers, so now I can actually edit it and it works a familiar class component. If you work with React you probably write a lot of  those but let's take a step back what if we didn't have to write a class when we want use state? So I'm not sure how that's gonna work but I'll just start with what I know, I want to render an input, so I'm gonna put an input here and the input has a value and that value is the current name, so I'll just pass name. I don't know where to get name from , so it doesn't come from props. I'll just declare it and I don't know, I'll fit it in later, this is gonna have a change down there as well , so I'm going do declare unchanged handle name change and I'm adding a function here takes an event and then here I want tell React to set the name to something, but again I'm not sure how to do that from a functional component so I'll just call something called setName with current input value, and I'll just upload it here. All right, so these two things, they're closely related, right, so one of them is the current value of the name state variable and the other is a function that lets us set the name state variable. And so because these things are closely related I'm going to put them together as a pair of values, so I'm going to get them from somewhere, so where do I get them from , from local state, so how do I use React local state from a function component, well what if I could just use state and past the initial state to specify it, and see if this works, yeah it works. So let's compare the two approaches, so on the left we have a familiar class component , this state has to be an object, we bind some event handlers so that we can access this inside the event handler, for this that's a state. When we call setState it actually doesn't just set the state that merges, the state are the argument into the state object and then when we want to access the state which it is that state and that's something. So in the example on the right we don't need to access this that stayed at something because the name state variable is already available in the function, it's just the variable and similarly when we need to set the state, we don't need to access this that's something, because the function that let's has said the name is also available in the scope, so what is use state exactly your state is a hook. A hook is a function provided by React that lets you hook into React features from your function components and you stated is the first hook that we're going to take a look at today but there are a few more so we're going to see them later.

All right , so let's go back to our familiar class example , so let's say we wanted to add a second field, for example , for a surname, so the way we normally do this is we add another key to the state and I'm going to copy and paste this row, it's gonna say surname now, it's going to render surname and handle surname change when I copy and paste this event handler, this will be surname and I need to bind it . So we can see that it works. So how do we do the same with hooks, so one thing we could do is we could make our state an object, as you can see that the state, with hook state doesn't have to be an object, it can be any primitive, we could make it an object if we wanted to but we also don't have to. So conceptually surname is not closely related to state to the name , so what we could do is we could declare a second state variable by calling the useState hook again. So all declare surname I can give it any name, it's just the variable in my code and sets her name by calling useState and passing the initial state for that state variable poppins. So again I gonna copy and paste the row say in surname, the value surname, surname handle surname change and when the user edit the surname, not sir name, we want to set the surname. Let's see if this works. It looks like it works.



So we can see that we can use hooks more than once in a component .Let's compare  the two approaches in more detail. So on the left familiar class component, state is always an object, has multiple fields, we call setState will merge some into that object and then when we want to access it we do this that state there's something. On the right in  the example using hooks we use the state hook twice and that declares two state variables, name and surname, and whenever we call set name or set surname, this tells React that it needs to re-render this component just like if we called setState and so the next time React render our components is going to pass the current name and the current surname to our component. And then we can use it directly without accessing this,  that state, that's something.



All right, let's go back to our class example. What else , what are other features of React we know, so another thing you might want to do from a component is to read context, so context, in case you're not familiar, it's like kind of like global variables for a subtree, so it's useful for things like read the current, theme like visual them or the current language that the user is using and it's useful to avoid passing everything through props if you need all  components to be able to read some value. So we're going to import theme context and local context which I already declared in another file. And the API you've probably most familiar with for consuming context especially especially if you have to consume multiple context is the render prop API. And it looks like this , so I'm going to scroll down here, so we can choose theme context, consumer, that gives us a theme in my case , it's just  going to be a CSS class, so I copy this, all this code inside the render props, and I'm going to use class name equals theme. All right , very old-time.And I also want to show the current language, so I'm going to use local context consumer and it's going to render another role. So I will copy and paste this row, can I say language, language, and render it here , ok, we can see that context works. And that's how we consume context. We actually added a more convenient API for accessing it in classes in 1606, but this is how you can see multiple contexts. So let's look at how we could do this with hooks. So as we said that state is a fundamental feature of React and this is why you can use state. And so if we want to use context , I need to import my contexts, so this is gonna be a themed context, local context and now if I want to use context from my component I can use context, and then to get the current theme, I can useContext, theme context and to get the current locale, I can useContext , local context. And this doesn't just read the context , it also subscribes the component to updates to this context, but it just gives me the current values so I can put it into my CSS class name and I can add the row,  first language, and I can put it here.



All right,, let's compare the two approaches. So this is the traditional kind of render prop API, it is very explicit about what it's doing, but it does get a little bit nested and you encounter this not just context, with any kind of render property API. So with hooks it does the same thing, but it's flat. so we just say we use useContext in this context and we get the theme and local and we can use them. So you might be wondering at this point how can React possibly know, for example, I have this to you useState calls, so how does it know which state variable corresponds  to which you state call. And the answer is that React relies one the order of these calls.This may be a little bit unusual. And in order for this to work correctly there is a rule that you need to follow when you use hooks and the rule is that you cannot call hook inside a condition.It has to be at the top level of your component. So if I do something like ,if props condition and then I call the useState hook here we actually have a linter plugin that is going to complain that this is not the correct way to use hooks. And we realize that this is an unusual limitation, but it is pretty important for hooks work correctly and also to enable certain things that I think you will like that I will show a bit later.



All right, so let's go back to our class.So the other thing you might want to reach for the class is lifecycle methods, so the most commonly use case for lifecycle methods is you want to perform some side effect such as firing off request, performing some kind of imerative Dom mutation, interfacing with the browser api's, so you might want to do something like this and you can't do during rendering because it's not rendered yet. So the way you do side-effects and React is you declare a lifecycle method, like componentDidMount and then let's say that if, let me show this, so you see at the top of the screen it say React App, so there is actually a browser API that lets us update this.So let's say we want the tab title to be the name of the person and change it as I type and so to set it initially. I'm going , there is a browser API to do this is document.title equals this, that stayed that name, was space, was this , the state that's her name. So now we can see it's as Mary Poppins. But then if I edit it , it doesn't get automatically updated, because I also need to implement componentDidUpdate, for the side effects to be consistent with what I rendered . So I'm going to declare a componentDidUpdate and just copy and paste this. All right, so now says Mary Poppings, but if I editing it the document title updates and this is how we perform side effects in a class . So how do we do this with hooks, well the ability to perform side effects is another core feature of React components, so if we want to use an effect from our, make an  import, useEffect, from the react and then we want to tell React what to do after React has flushed our components to the Dom. So we pass a which is where we perform our effect. So I'm going to say document dot title equals name plus space, plus surname, you can see it says Mary Poppins here. And if I start editing, it actually updates. So what default useEffect runs both after the initial render and after every update, so by default , it is consistent with what he rendered and you can opt out of this behavior if like for performance reasons and/or if you have special logic and reinstall after me will touch a little bit on this. So let's compares the two approaches. So in the class we divide method , we divided the logic based on lifecycle method names, so this is why we have componentDidMount, componentDidUpdate,  they fire at different times and we sometimes repeat some logic between them, we could extract it to a function but still we would have to call it in two places and remember to keep it consistent. And with the effect hook , the effects are consistent by default, although there is a way to opt out of that, and not is that in the class we need to access this dot state , so there needs  to be special API to do this, but in the effect example, we actually don't need a special API to access the state variable, because it's already in this code of the function it is declared right above. And this is why the effect is declared inside the component rather than outside, because this give us access to state variables, ability so set them and anything else like the current context value for example, or any of these contexts.



All right, let's go back to the familiar class example, another thing you might want to use lifecycle methods for in a class is subscriptions, so maybe you want subscribe to some kind of browser API and it gives you some value, for example, the window size and you want to update the state in response to changes to this value, and so the way we could to this in a class, let's say that we want to monitor the window width, so i'm going to put width into state, this window in there with browser API and I want to render it, let me copy and paste this. So this is gonna say width and I'm going to render it here, this dot state dot width, this is the width of the window, not width of Mary Poppings. I'm going to add in event listener , so we need to actually listen to changes in the widht , so window dot event, , add event listener. I'm going to listen to the resize event, handle resize, and I need to declare this event , so this is where we're going to update the width state to be window dot inner width . And we need to bind it. And I also need to unsubscribe, so I don't want a memory leak with,  like keeping these subscriptions,I want to unsubscribe from this event , so the way we do this in a class is we create another lifecycle method called componentWillUnmount and I'm going to copy and paste this logic here, except this will be a remove event listener. So we set up an event listener and we remove the event listener, and we can verify that this actually works by dragging this , you see the width is changing, so it works. So let's see how we could do this with hooks. So conceptually listening to the window width has nothing to do with setting the document title, so that's why we're not gonna put it in that effect, it's conceptually completely separate effect and just like we could use state more than once to declare multiple state variables. We can use effect more than once to perform different side effects.So I want to subscribe to window  addEventListener, resize, handleResize and I'm gonna to keep some state for the current width, so I'm actually going to declare another state variable, so we get them by useState width window inner width as the initial value. And now in my handle resize function, I'll just declare it here because it isn't used anywhere else and it's going to set width value the current width. I need to render it , so I'll copy and paste this row, gonna say width. And finally I need to clean up after this effect, so I need to specify how to clean up and again conceptually cleaning up is part of the effect, so this effect has a cleaner place, and the order you , the way you can specify it is that any effect can optionally return a function, and if it does return the function, then React will call this function to clean up after the effect. So this is where we unscribe. Ok, let's just verify that this actually works.



So let's compare the two approaches, on the left we have a familiar class component, nothing surprising there, we have some side effects, some related logic is split apart, so we can see that document title is being set here but it's also being set here,  and then we subscribe to an effect here , but we unsubscribe here , so there things need to be in sync with each other. And then this method contains two unrelated method , two unrelated lines , so that me in the,  in future make it a bit difficult to test them in isolation, but it looks very familiar, so that's, this nice. So this code probably looks less familiar but let's take another look at what's going on here. In,  with hooks we separate code not based on the life cycle method name, but based on what code is doing, so we can see that there is one effect which is we updated document title, that's one thing this component can do, and then there is another effect which is subscribing to the window resize event and update in the state when it changes, and this effect has a clean up phase which means that when it's time to remove this effect, React removes it and avoids the memory leaks. And if you've been carefully watching you might notice that since effect run after every render, we just gonna keep resubscribing, so there is a way to optimize this. So default is to be consistent which is important if you , for example, use some prop here , I need to resubscribe from different id from props or something similar, but there is a way to optimize it and opt out of this behavior and Ryan in the next talk will mention how to do it.

43分21秒